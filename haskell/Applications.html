<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Applications</title>
<!-- 2017-03-06 seg 12:32 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="arch" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link href='/theme/style.css' rel='stylesheet'>

<script type="text/javascript" src="/theme/org-info.js">
/**
 *
 * @source: /theme/org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in /theme/org-info.js.
 *
 * Copyright (C) 2012-2013 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in /theme/org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "3");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Applications</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Applications</a>
<ul>
<li><a href="#sec-1-1">1.1. Mathematics</a></li>
<li><a href="#sec-1-2">1.2. Piecewise Functions</a></li>
<li><a href="#sec-1-3">1.3. Numerical Methods</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1. Polynomial</a></li>
<li><a href="#sec-1-3-2">1.3.2. Numerical Derivate</a></li>
<li><a href="#sec-1-3-3">1.3.3. Nonlinear Equation - Root-finding</a></li>
<li><a href="#sec-1-3-4">1.3.4. Differential Equations</a></li>
</ul>
</li>
<li><a href="#sec-1-4">1.4. Statistics and Time Series</a>
<ul>
<li><a href="#sec-1-4-1">1.4.1. Some Statistical Functions</a></li>
<li><a href="#sec-1-4-2">1.4.2. Monte Carlo Simulation Coin Toss</a></li>
</ul>
</li>
<li><a href="#sec-1-5">1.5. Vectors</a></li>
<li><a href="#sec-1-6">1.6. Tax Brackets</a></li>
<li><a href="#sec-1-7">1.7. Small DSL Domain Specific Language</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Applications</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Mathematics</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<b>Trigonometric Degree Functions</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">deg2rad</span> deg <span class="org-haskell-operator">=</span> deg<span class="org-haskell-operator">*</span>pi<span class="org-haskell-operator">/</span>180.0  <span class="org-comment-delimiter">-- </span><span class="org-comment">convert degrees to radians</span>
<span class="org-haskell-definition">rad2deg</span> rad <span class="org-haskell-operator">=</span> rad<span class="org-haskell-operator">*</span>180.0<span class="org-haskell-operator">/</span>pi  <span class="org-comment-delimiter">-- </span><span class="org-comment">convert radians to degrees</span>

<span class="org-haskell-definition">sind</span> <span class="org-haskell-operator">=</span> sin <span class="org-haskell-operator">.</span> deg2rad        
<span class="org-haskell-definition">cosd</span> <span class="org-haskell-operator">=</span> cos <span class="org-haskell-operator">.</span> deg2rad        
<span class="org-haskell-definition">tand</span> <span class="org-haskell-operator">=</span> tan <span class="org-haskell-operator">.</span> deg2rad
<span class="org-haskell-definition">atand</span> <span class="org-haskell-operator">=</span> rad2deg <span class="org-haskell-operator">.</span> atan
<span class="org-haskell-definition">atan2d</span> y x <span class="org-haskell-operator">=</span> rad2deg (atan2 y x )
</pre>
</div>

<p>
Example:
</p>


<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">map</span> rad2deg [pi<span class="org-haskell-operator">/</span>6, pi<span class="org-haskell-operator">/</span>4, pi<span class="org-haskell-operator">/</span>3, pi<span class="org-haskell-operator">/</span>2, pi]
[29.999999999999996,45.0,59.99999999999999,90.0,180.0]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">map</span> sind [30.0, 45.0, 60.0, 90.0, 180.0 ]
[0.49999999999999994,0.7071067811865475,0.8660254037844386,1.0,1.2246063538223773e-16]
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Piecewise Functions</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Implement the following functions in Haskell
</p>

<pre class="example">
       /  0.10    if 0.0      &lt;= x &lt;= 7150.0
       |  0.15    if 7150.0   &lt;  x &lt;= 29050.0
       |  0.25    if 29050.0  &lt;  x &lt;= 70350.0
f1(x)= |  0.28    if 70350.0  &lt;  x &lt;= 146750.0
       |  0.33    if 146750.0 &lt;  x &lt;= 319100.0
       \  0.35    if 139100.0 &lt;  x &lt; +infinitum


       /  x^2 - 1  if x &lt; 0
f2(x) = |  x   - 1  if 0 &lt;= x &lt; 4
       \  3        if x &gt; 4
</pre>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Graphics.Gnuplot.Simple</span>

(<span class="org-haskell-definition">|&gt;</span>) x f <span class="org-haskell-operator">=</span> f x
(<span class="org-haskell-definition">|&gt;&gt;</span>) x f <span class="org-haskell-operator">=</span> map f x

<span class="org-haskell-definition">pairs</span> xs <span class="org-haskell-operator">=</span> zip xs (tail xs)

<span class="org-haskell-definition">infp</span> <span class="org-haskell-operator">=</span>    1.0e30  <span class="org-comment-delimiter">-- </span><span class="org-comment">Plus Infinite</span>
<span class="org-haskell-definition">infm</span> <span class="org-haskell-operator">=</span> (<span class="org-haskell-operator">-</span>1.0e30)  <span class="org-comment-delimiter">-- </span><span class="org-comment">Minus Infinite</span>

<span class="org-haskell-definition">inInterval</span> x (p1, p2) <span class="org-haskell-operator">=</span> (fst p1) <span class="org-haskell-operator">&lt;</span> x <span class="org-haskell-operator">&amp;&amp;</span> x <span class="org-haskell-operator">&lt;=</span> (fst p2) 

<span class="org-haskell-definition">piecewiseFactory</span> intervalTable x <span class="org-haskell-operator">=</span> f x
    <span class="org-haskell-keyword">where</span>
    f <span class="org-haskell-operator">=</span>  filter (inInterval x) (pairs intervalTable) 
        <span class="org-haskell-operator">|&gt;</span> head 
        <span class="org-haskell-operator">|&gt;</span> fst 
        <span class="org-haskell-operator">|&gt;</span> snd 

<span class="org-haskell-definition">arange</span> start stop step <span class="org-haskell-operator">=</span> [start,(start<span class="org-haskell-operator">+</span>step)<span class="org-haskell-operator">..</span>(stop<span class="org-haskell-operator">-</span>step)]

<span class="org-haskell-definition">plotFxs</span> f xs  <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    <span class="org-haskell-keyword">let</span> ys <span class="org-haskell-operator">=</span> map f xs
    plotList <span class="org-haskell-constructor">[]</span> (zip xs ys)


<span class="org-haskell-definition">f1_table</span> <span class="org-haskell-operator">=</span> 
    [
    (0.0,        const 0.10),
    (7150.0,     const 0.15),
    (29050.0,    const 0.25),
    (70350.0,    const 0.28),
    (146750.0,   const 0.33),  
    (319100.0,   const 0.35),  
    (1.0e30,     const 0.35)
    ]

<span class="org-haskell-definition">f2_table</span> <span class="org-haskell-operator">=</span> [
    (infm,  <span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x<span class="org-haskell-operator">**</span>2 <span class="org-haskell-operator">-</span> 1), <span class="org-comment-delimiter">--  </span><span class="org-comment">if -&#8734; &lt; x &lt;= 0  -&gt; x^2 - 1 </span>
    (0.0,   <span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">-</span> 1.0 ), <span class="org-comment-delimiter">--  </span><span class="org-comment">if 0  &lt; x &lt;= 4  -&gt; x   - 1</span>
    (4.0,   <span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> 3.0),      <span class="org-comment-delimiter">--  </span><span class="org-comment">if 4  &lt; x &lt;= +&#8734; -&gt; 3.0</span>
    (infp,  <span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> 3.0 )
    ]

<span class="org-haskell-definition">f1</span> <span class="org-haskell-operator">=</span> piecewiseFactory f1_table
<span class="org-haskell-definition">f2</span> <span class="org-haskell-operator">=</span> piecewiseFactory f2_table
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">plotFxs</span> f1 <span class="org-haskell-operator">$</span> arange (1.0) 400000 1000.0
</pre>
</div>

<p>
!<i>f1 chart</i>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">plotFxs</span> f2 <span class="org-haskell-operator">$</span> arange (<span class="org-haskell-operator">-</span>4) 4 0.01
</pre>
</div>


<p>
!<i>f2 chart</i>
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Numerical Methods</h3>
<div class="outline-text-3" id="text-1-3">
</div><div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> Polynomial</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Polynomial evaluation by the horner method.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">polyval</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Fractional</span> a <span class="org-haskell-operator">=&gt;</span> [a] <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> a
<span class="org-haskell-definition">polyval</span> coeffs x <span class="org-haskell-operator">=</span> foldr (<span class="org-haskell-operator">\</span>b c <span class="org-haskell-operator">-&gt;</span> b <span class="org-haskell-operator">+</span> x<span class="org-haskell-operator">*</span>c) 0 coeffs

<span class="org-haskell-definition">polyderv</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Fractional</span> a <span class="org-haskell-operator">=&gt;</span> [a] <span class="org-haskell-operator">-&gt;</span> [a] 
<span class="org-haskell-definition">polyderv</span> coeffs <span class="org-haskell-operator">=</span> zipWith (<span class="org-haskell-operator">*</span>) (map fromIntegral [1<span class="org-haskell-operator">..</span>n]) (tail coeffs )
    <span class="org-haskell-keyword">where</span>
    n <span class="org-haskell-operator">=</span> (length coeffs) <span class="org-haskell-operator">-</span> 1
</pre>
</div>

<p>
Example:
</p>

<pre class="example">
Reference: http://www.math10.com/en/algebra/horner.html

f(x) = a0 + a1x + a2x2 + a3x3 + a4x4 + a5x5
f(x0) = a0 + x0(a1 + x0(a2 + x0(a3 + x0(a4 + a5x0)))) 

Example: Evaluate the polynomial 
    f(x)  =  1x4 + 3x3 + 5x2 + 7x + 9 at x = 2 
    df(x) =  3x3 + 6x2 + 10x +  7
</pre>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> coeffs  <span class="org-haskell-operator">=</span> [9.0, 7.0, 5.0, 3.0, 1.0] 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> f  <span class="org-haskell-operator">=</span> polyval  coeffs

<span class="org-haskell-keyword">let</span> df <span class="org-haskell-operator">=</span> polyval <span class="org-haskell-operator">$</span>  polyderv coeffs

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">polyderv</span> coeffs 
[7.0,10.0,9.0,4.0]

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">f</span> 2
83.0

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">df</span> 2
95.0

<span class="org-haskell-operator">&gt;</span> (<span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> 7 <span class="org-haskell-operator">+</span> 10<span class="org-haskell-operator">*</span>x <span class="org-haskell-operator">+</span> 9<span class="org-haskell-operator">*</span>x<span class="org-haskell-operator">^</span>2 <span class="org-haskell-operator">+</span> 4<span class="org-haskell-operator">*</span>x<span class="org-haskell-operator">^</span>3) 2
95
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> Numerical Derivate</h4>
<div class="outline-text-4" id="text-1-3-2">
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">derv</span> dx f x <span class="org-haskell-operator">=</span> (f(x<span class="org-haskell-operator">+</span>dx) <span class="org-haskell-operator">-</span> f(x))<span class="org-haskell-operator">/</span>dx

<span class="org-haskell-definition">f</span> x <span class="org-haskell-operator">=</span> 2<span class="org-haskell-operator">*</span>x<span class="org-haskell-operator">**</span>2 <span class="org-haskell-operator">-</span> 2<span class="org-haskell-operator">*</span>x
<span class="org-haskell-definition">df</span> <span class="org-haskell-operator">=</span> derv 1e-5 f

<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> map f [2, 3, 4, 5] 
[4.0,12.0,24.0,40.0]
<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> df <span class="org-haskell-operator">=</span> derv 1e-5 f
<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> map df  [2, 3, 4, 5]
[6.000020000040961,10.000019999978349,14.000019999116374,18.000019998964945]
<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> dfx x <span class="org-haskell-operator">=</span> 4<span class="org-haskell-operator">*</span>x <span class="org-haskell-operator">-</span> 2
<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> map dfx [2, 3, 4, 5]
[6,10,14,18]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> Nonlinear Equation - Root-finding</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
See also: 
</p>

<ul class="org-ul">
<li><a href="http://en.wikipedia.org/wiki/Root-finding_algorithm">Root finding</a>
</li>
<li><a href="http://en.wikipedia.org/wiki/Newton's_method">Newton's method</a>
</li>
<li><a href="http://en.wikipedia.org/wiki/Bisection_method">Bisection method</a>
</li>
</ul>

<p>
<b>Bisection Method</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">bisection_iterator</span> <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">Floating</span> a, <span class="org-haskell-type">Floating</span> a1, <span class="org-haskell-type">Ord</span> a1) <span class="org-haskell-operator">=&gt;</span> (a <span class="org-haskell-operator">-&gt;</span> a1) <span class="org-haskell-operator">-&gt;</span> [a] <span class="org-haskell-operator">-&gt;</span> [a]
<span class="org-haskell-definition">bisection_iterator</span> f guesslist <span class="org-haskell-operator">=</span> newguess
    <span class="org-haskell-keyword">where</span>
    a <span class="org-haskell-operator">=</span>  guesslist <span class="org-haskell-operator">!!</span> 0
    b <span class="org-haskell-operator">=</span>  guesslist <span class="org-haskell-operator">!!</span> 1
    c <span class="org-haskell-operator">=</span> (a<span class="org-haskell-operator">+</span>b)<span class="org-haskell-operator">/</span>2.0
    p <span class="org-haskell-operator">=</span> f(a)<span class="org-haskell-operator">*</span>f(c)
    newguess <span class="org-haskell-operator">=</span> (<span class="org-haskell-operator">\</span>p <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">if</span> p <span class="org-haskell-operator">&lt;</span> 0.0 <span class="org-haskell-keyword">then</span> [a, c] <span class="org-haskell-keyword">else</span> [c, b] ) p


<span class="org-haskell-definition">bisectionSolver</span> eps itmax f x1 x2 <span class="org-haskell-operator">=</span> (root, error, iterations) 
    <span class="org-haskell-keyword">where</span>  

    bisection_error xlist <span class="org-haskell-operator">=</span> abs(f <span class="org-haskell-operator">$</span> xlist <span class="org-haskell-operator">!!</span> 1)
    check_error xlist <span class="org-haskell-operator">=</span> bisection_error xlist <span class="org-haskell-operator">&gt;</span> eps

    iterator <span class="org-haskell-operator">=</span> bisection_iterator  f

    rootlist <span class="org-haskell-operator">=</span> [x1, x2] <span class="org-haskell-operator">|&gt;</span> iterate iterator <span class="org-haskell-operator">|&gt;</span> takeWhile check_error <span class="org-haskell-operator">|&gt;</span> take itmax

    pair <span class="org-haskell-operator">=</span> last rootlist <span class="org-haskell-operator">|&gt;</span> iterator
    root <span class="org-haskell-operator">=</span> last pair
    error <span class="org-haskell-operator">=</span> bisection_error pair

    iterations <span class="org-haskell-operator">=</span> length rootlist    

<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> f x  <span class="org-haskell-operator">=</span>  exp(<span class="org-haskell-operator">-</span>x) <span class="org-haskell-operator">-</span>3<span class="org-haskell-operator">*</span>log(x)
<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> bisectionSolver 1e-5 100 f 0.05 3
(1.1154509544372555,8.86237816760671e-6,19)
<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
<b>Newton Raphson Method</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-comment-delimiter">{-</span>
<span class="org-comment">Newton-Raphson Method Iterator, builds an iterator function</span>
<span class="org-comment">from the function to be solved and its derivate.</span>

<span class="org-comment">-}</span>
<span class="org-haskell-definition">newton_iterator</span> f df x <span class="org-haskell-operator">=</span> x <span class="org-haskell-operator">-</span> f(x)<span class="org-haskell-operator">/</span>df(x)

<span class="org-comment-delimiter">{-</span><span class="org-comment">--------------------------------------------------------------------</span>
<span class="org-comment">    newtonSolver(eps, itmax, f, df, guess)</span>

<span class="org-comment">    Solve equation using the Newton-Raphson Method.</span>

<span class="org-comment">    params:</span>

<span class="org-comment">        eps   :  Tolerance of the solver</span>
<span class="org-comment">        itmax :  Maximum number of iterations</span>
<span class="org-comment">        f     :  Function which the root will be computed</span>
<span class="org-comment">        df    :  Derivate of the function</span>
<span class="org-comment">        guess :  Initial guess </span>

<span class="org-comment">newtonSolver</span>
<span class="org-comment">  :: (Fractional t, Ord t) =&gt;</span>
<span class="org-comment">     t -&gt; Int -&gt; (t -&gt; t) -&gt; (t -&gt; t) -&gt; t -&gt; (t, t, Int)</span>
<span class="org-comment">-----------------------------------------------------------------------</span>
<span class="org-comment">-}</span>
<span class="org-haskell-definition">newtonSolver</span> <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">Floating</span> t, <span class="org-haskell-type">Ord</span> t) <span class="org-haskell-operator">=&gt;</span> t <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> (t <span class="org-haskell-operator">-&gt;</span> t) <span class="org-haskell-operator">-&gt;</span> (t <span class="org-haskell-operator">-&gt;</span> t) <span class="org-haskell-operator">-&gt;</span> t <span class="org-haskell-operator">-&gt;</span> (t, t, <span class="org-haskell-type">Int</span>)
<span class="org-haskell-definition">newtonSolver</span> eps itmax f df guess <span class="org-haskell-operator">=</span> (root, error, iterations)
    <span class="org-haskell-keyword">where</span>
    check_root x <span class="org-haskell-operator">=</span> abs(f(x)) <span class="org-haskell-operator">&gt;</span> eps                                  
    iterator <span class="org-haskell-operator">=</span> newton_iterator f df   <span class="org-comment-delimiter">-- </span><span class="org-comment">Builds the Newton Iterator                              </span>
    generator <span class="org-haskell-operator">=</span> iterate <span class="org-haskell-operator">$</span> iterator    <span class="org-comment-delimiter">-- </span><span class="org-comment">Infinite List that will that holds the roots (Lazy Evaluation)</span>

    rootlist <span class="org-haskell-operator">=</span> take itmax <span class="org-haskell-operator">$</span> takeWhile check_root <span class="org-haskell-operator">$</span> generator guess                                  
    root <span class="org-haskell-operator">=</span> iterator <span class="org-haskell-operator">$</span> last <span class="org-haskell-operator">$</span> rootlist                                  
    error <span class="org-haskell-operator">=</span> abs(f(root))
    iterations <span class="org-haskell-operator">=</span> length rootlist


<span class="org-haskell-definition">square_root</span> a <span class="org-haskell-operator">|</span> a <span class="org-haskell-operator">&gt;</span> 0       <span class="org-haskell-operator">=</span> newtonSolver 1e-6 50 (<span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x<span class="org-haskell-operator">^</span>2 <span class="org-haskell-operator">-</span>a) (<span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> 2<span class="org-haskell-operator">*</span>x) a 
              <span class="org-haskell-operator">|</span> otherwise   <span class="org-haskell-operator">=</span> error (<span class="org-string">"The argument must be positive"</span>)

<span class="org-comment-delimiter">{- </span>
<span class="org-comment">    Solve f(x) = x^2 - 2 = 0 </span>

<span class="org-comment">    The solution is sqrt(2)</span>
<span class="org-comment">-}</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> f x <span class="org-haskell-operator">=</span> x<span class="org-haskell-operator">^</span>2 <span class="org-haskell-operator">-</span> 2.0
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> df x <span class="org-haskell-operator">=</span> 2<span class="org-haskell-operator">*</span>x
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> df x <span class="org-haskell-operator">=</span> 2.0<span class="org-haskell-operator">*</span>x
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">newtonSolver</span> 1e-3 100 f df 5
(1.414470981367771,7.281571315052027e-4,4)
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">newtonSolver</span> 1e-3 100 f df 50
(1.4142150098491113,4.094082521888254e-6,8)
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
<b>Secant Method</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell">(<span class="org-haskell-definition">|&gt;</span>) x f <span class="org-haskell-operator">=</span> f x
(<span class="org-haskell-definition">|&gt;&gt;</span>) x f <span class="org-haskell-operator">=</span> map f x

<span class="org-haskell-definition">secant_iterator</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Floating</span> t <span class="org-haskell-operator">=&gt;</span> (t <span class="org-haskell-operator">-&gt;</span> t) <span class="org-haskell-operator">-&gt;</span> [t] <span class="org-haskell-operator">-&gt;</span> [t]
<span class="org-haskell-definition">secant_iterator</span> f guesslist <span class="org-haskell-operator">=</span> [x, xnext]
    <span class="org-haskell-keyword">where</span>
    x <span class="org-haskell-operator">=</span>  guesslist <span class="org-haskell-operator">!!</span> 0
    x_ <span class="org-haskell-operator">=</span> guesslist <span class="org-haskell-operator">!!</span> 1
    xnext <span class="org-haskell-operator">=</span> x <span class="org-haskell-operator">-</span> f(x)<span class="org-haskell-operator">*</span>(x<span class="org-haskell-operator">-</span>x_)<span class="org-haskell-operator">/</span>(f(x) <span class="org-haskell-operator">-</span> f(x_))

<span class="org-haskell-definition">secantSolver</span> eps itmax f x1 x2 <span class="org-haskell-operator">=</span> (root, error, iterations) 
    <span class="org-haskell-keyword">where</span>  

    secant_error xlist <span class="org-haskell-operator">=</span> abs(f <span class="org-haskell-operator">$</span> xlist <span class="org-haskell-operator">!!</span> 1)
    check_error xlist <span class="org-haskell-operator">=</span> secant_error xlist <span class="org-haskell-operator">&gt;</span> eps

    iterator <span class="org-haskell-operator">=</span> secant_iterator  f

    rootlist <span class="org-haskell-operator">=</span> [x1, x2] <span class="org-haskell-operator">|&gt;</span> iterate iterator <span class="org-haskell-operator">|&gt;</span> takeWhile check_error <span class="org-haskell-operator">|&gt;</span> take itmax

    pair <span class="org-haskell-operator">=</span> last rootlist <span class="org-haskell-operator">|&gt;</span> iterator
    root <span class="org-haskell-operator">=</span> last pair
    error <span class="org-haskell-operator">=</span> secant_error pair

    iterations <span class="org-haskell-operator">=</span> length rootlist

<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> f x <span class="org-haskell-operator">=</span> x<span class="org-haskell-operator">^</span>2 <span class="org-haskell-operator">-</span> 2.0
<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> secantSolver  1e-4 20 f 2 3
(1.4142394822006472,7.331301515467459e-5,6)
<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> f x <span class="org-haskell-operator">=</span> exp(x) <span class="org-haskell-operator">-</span> 3.0<span class="org-haskell-operator">*</span>x<span class="org-haskell-operator">^</span>2
<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span> secantSolver 1e-5 100 f (<span class="org-haskell-operator">-</span>2.0)  3.0
(<span class="org-haskell-operator">-</span>0.458964305393305,6.899607281729558e-6,24)
<span class="org-haskell-operator">*</span><span class="org-haskell-constructor">Main</span><span class="org-haskell-operator">&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> Differential Equations</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
<b>Euler Method</b>
</p>

<p>
The task is to implement a routine of Euler's method and then to use it to solve the given example of Newton's cooling law with it for three different step sizes of 2 s, 5 s and 10 s and to compare with the analytical solution. The initial temperature T0 shall be 100 °C, the room temperature TR 20 °C, and the cooling constant k 0.07. The time interval to calculate shall be from 0 s to 100 s
</p>

<p>
From: <a href="http://rosettacode.org/wiki/Euler_method">http://rosettacode.org/wiki/Euler_method</a>
</p>

<pre class="example">
Solve differential equation by the Euler's Method.

    T(t)
    ---- =  -k(T(t) - Tr)
     dt
    
    T(t) = Tr + k(T0(t) - Tr).exp(-k*t)
</pre>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Graphics.Gnuplot.Simple</span>


<span class="org-haskell-definition">eulerStep</span> f step (x, y)<span class="org-haskell-operator">=</span> (xnew, ynew)
                    <span class="org-haskell-keyword">where</span>
                    xnew <span class="org-haskell-operator">=</span> x <span class="org-haskell-operator">+</span> step
                    ynew <span class="org-haskell-operator">=</span> y <span class="org-haskell-operator">+</span> step <span class="org-haskell-operator">*</span> (f (x, y))

<span class="org-haskell-definition">euler</span> <span class="org-haskell-operator">::</span> ((<span class="org-haskell-type">Double</span>, <span class="org-haskell-type">Double</span>) <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span>) <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span> <span class="org-haskell-operator">-&gt;</span> [(<span class="org-haskell-type">Double</span>, <span class="org-haskell-type">Double</span>)]
<span class="org-haskell-definition">euler</span> f x0 xf y0 step <span class="org-haskell-operator">=</span> xypairs
                     <span class="org-haskell-keyword">where</span>
                     iterator <span class="org-haskell-operator">=</span> iterate <span class="org-haskell-operator">$</span> eulerStep f step
                     xypairs <span class="org-haskell-operator">=</span> takeWhile (<span class="org-haskell-operator">\</span>(x, y) <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">&lt;=</span> xf ) <span class="org-haskell-operator">$</span> iterator (x0, y0)

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> dTemp k temp_r (t, temp) <span class="org-haskell-operator">=</span> <span class="org-haskell-operator">-</span>k<span class="org-haskell-operator">*</span>(temp <span class="org-haskell-operator">-</span> temp_r)

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">euler</span> (dTemp 0.07 20.0) 0.0 100.0 100.0 5.0
[(0.0,100.0),(5.0,72.0),(10.0,53.8),(15.0,41.97) <span class="org-haskell-operator">\.\.\.</span>
(100.0,20.01449963666907)]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-keyword">let</span> t_temp <span class="org-haskell-operator">=</span> euler (dTemp 0.07 20.0) 0.0 100.0 100.0 5.0

<span class="org-haskell-definition">plotList</span> <span class="org-haskell-constructor">[]</span> t_temp
</pre>
</div>


<div class="figure">
<p><img src="images/euler_newton_cooling.png" alt="euler_newton_cooling.png" />
</p>
</div>

<p>
<b>Runge Kutta RK4</b>
</p>

<p>
See also: <a href="http://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods">Runge Kutta Methods</a>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Graphics.Gnuplot.Simple</span>

<span class="org-haskell-definition">rk4Step</span> f h (x, y) <span class="org-haskell-operator">=</span> (xnext, ynext)
                      <span class="org-haskell-keyword">where</span>

                      k1 <span class="org-haskell-operator">=</span> f (x, y)
                      k2 <span class="org-haskell-operator">=</span> f (x<span class="org-haskell-operator">+</span>h<span class="org-haskell-operator">/</span>2, y<span class="org-haskell-operator">+</span>h<span class="org-haskell-operator">/</span>2<span class="org-haskell-operator">*</span>k1)
                      k3 <span class="org-haskell-operator">=</span> f (x<span class="org-haskell-operator">+</span>h<span class="org-haskell-operator">/</span>2, y<span class="org-haskell-operator">+</span>h<span class="org-haskell-operator">/</span>2<span class="org-haskell-operator">*</span>k2)
                      k4 <span class="org-haskell-operator">=</span> f (x<span class="org-haskell-operator">+</span>h,y<span class="org-haskell-operator">+</span>h<span class="org-haskell-operator">*</span>k3)

                      xnext <span class="org-haskell-operator">=</span> x <span class="org-haskell-operator">+</span> h
                      ynext <span class="org-haskell-operator">=</span> y <span class="org-haskell-operator">+</span> h<span class="org-haskell-operator">/</span>6<span class="org-haskell-operator">*</span>(k1<span class="org-haskell-operator">+</span>2<span class="org-haskell-operator">*</span>k2<span class="org-haskell-operator">+</span>2<span class="org-haskell-operator">*</span>k3<span class="org-haskell-operator">+</span>k4)

<span class="org-haskell-definition">rk4</span> <span class="org-haskell-operator">::</span> ((<span class="org-haskell-type">Double</span>, <span class="org-haskell-type">Double</span>) <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span>) <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span> <span class="org-haskell-operator">-&gt;</span> [(<span class="org-haskell-type">Double</span>, <span class="org-haskell-type">Double</span>)]
<span class="org-haskell-definition">rk4</span> f x0 xf y0 h <span class="org-haskell-operator">=</span> xypairs
                     <span class="org-haskell-keyword">where</span>
                     iterator <span class="org-haskell-operator">=</span> iterate <span class="org-haskell-operator">$</span> rk4Step f h
                     xypairs <span class="org-haskell-operator">=</span> takeWhile (<span class="org-haskell-operator">\</span>(x, y) <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">&lt;=</span> xf ) <span class="org-haskell-operator">$</span> iterator (x0, y0)

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> dTemp k temp_r (t, temp) <span class="org-haskell-operator">=</span> <span class="org-haskell-operator">-</span>k<span class="org-haskell-operator">*</span>(temp <span class="org-haskell-operator">-</span> temp_r)
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> t_temp <span class="org-haskell-operator">=</span> rk4 (dTemp 0.07 20.0) 0.0 100.0 100.0 5.0
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">plotList</span> <span class="org-haskell-constructor">[]</span> t_temp
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Statistics and Time Series</h3>
<div class="outline-text-3" id="text-1-4">
</div><div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> Some Statistical Functions</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
Arithmetic Mean of a Sequence
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">mean</span> lst <span class="org-haskell-operator">=</span> sum lst <span class="org-haskell-operator">/</span> fromIntegral (length lst)
</pre>
</div>

<p>
Geometric Mean of Sequence 
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">geomean</span> lst <span class="org-haskell-operator">=</span> (product lst) <span class="org-haskell-operator">**</span> 1<span class="org-haskell-operator">/</span>(fromIntegral (length lst))
</pre>
</div>

<p>
Convert from decimal to percent
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">to_pct</span>   lst <span class="org-haskell-operator">=</span> map (100.0 <span class="org-haskell-operator">*</span>) lst <span class="org-comment-delimiter">{- </span><span class="org-comment">Decimal to percent -}</span>
<span class="org-haskell-definition">from_pct</span> lst <span class="org-haskell-operator">=</span> map (<span class="org-haskell-operator">/</span>100.0)  lsd <span class="org-comment-delimiter">{- </span><span class="org-comment">from Percent to Decimal -}</span>
</pre>
</div>

<p>
Lagged Difference of a time serie
</p>
<ul class="org-ul">
<li>lagddif [xi] = [x_i+1 - x_i]
</li>
</ul>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">lagdiff</span> lst <span class="org-haskell-operator">=</span> zipWith (<span class="org-haskell-operator">-</span>) (tail lst) lst
</pre>
</div>

<p>
Growth of a Time Series
</p>
<ul class="org-ul">
<li>growth [xi] = [(x_i+1 - x_i)/xi]
</li>
</ul>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">growth</span> lst <span class="org-haskell-operator">=</span> zipWith (<span class="org-haskell-operator">/</span>) (lagdiff lst) lst
</pre>
</div>

<p>
Percentual Growth
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">growthp</span> <span class="org-haskell-operator">=</span> to_pct <span class="org-haskell-operator">.</span> growth
</pre>
</div>

<p>
Standard Deviation and Variance of a Sequence
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-comment-delimiter">{- </span><span class="org-comment">Standard Deviation-}</span>
<span class="org-haskell-definition">stdev</span> values <span class="org-haskell-operator">=</span>  values   <span class="org-haskell-operator">|&gt;&gt;</span> (<span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">-</span>  mean values ) <span class="org-haskell-operator">|&gt;&gt;</span> (<span class="org-haskell-operator">^</span>2) <span class="org-haskell-operator">|&gt;</span> mean <span class="org-haskell-operator">|&gt;</span> sqrt

<span class="org-comment-delimiter">{- </span><span class="org-comment">Standard Variance -}</span>
<span class="org-haskell-definition">stvar</span> values <span class="org-haskell-operator">=</span> stdev values <span class="org-haskell-operator">|&gt;</span> (<span class="org-haskell-operator">^</span>2)
</pre>
</div>

<p>
<b>Example: Investment Return</b>
</p>

<p>
The annual prices of an Blue Chip company are given below,
find the percent growth rate at the end of each year and 
the <a href="http://www.investopedia.com/articles/analyst/041502.asp">CAGR</a> Compound annual growth rate.
</p>

<pre class="example">
year    0    1     2     3     4     5
price  16.06 23.83 33.13 50.26 46.97 39.89
</pre>

<p>
Solution:
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> (<span class="org-haskell-operator">|&gt;</span>) x f <span class="org-haskell-operator">=</span> f x
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> (<span class="org-haskell-operator">|&gt;&gt;</span>) x f <span class="org-haskell-operator">=</span> map f x
<span class="org-haskell-operator">&gt;</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> cagr prices <span class="org-haskell-operator">=</span> (growthp prices <span class="org-haskell-operator">|&gt;&gt;</span> (<span class="org-haskell-operator">+</span>100) <span class="org-haskell-operator">|&gt;</span> geomean ) <span class="org-haskell-operator">-</span> 100
<span class="org-haskell-operator">&gt;</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> prices <span class="org-haskell-operator">=</span> [16.06, 23.83, 33.13, 50.26, 46.97, 39.89 ]
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-comment-delimiter">{- </span><span class="org-comment">Percent Returns -}</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> returns <span class="org-haskell-operator">=</span> growthp prices
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> returns
[48.38107098381071,39.02643726395302,51.705402958044054,<span class="org-haskell-operator">-</span>6.545961002785513,<span class="org-haskell-operator">-</span>15.073451139024908]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> annual_cagr <span class="org-haskell-operator">=</span> cagr prices 
<span class="org-haskell-operator">&gt;</span> annual_cagr 
19.956476057259906
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> Monte Carlo Simulation Coin Toss</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
The simplest such situation must be the tossing of a coin. Any individual event will result in the coin falling with one side or the other uppermost (heads or tails). However, common sense tells us that, if we tossed it a very large number of times, the total number of heads and tails should become increasingly similar. For a greater number of tosses the percentage of heads or tails will be next to 50% in a non-biased coin. Credits: <a href="http://staff.argyll.epsb.ca/jreed/math7/strand4/4203.htm">Monte Carlo Simulation - Tossing a Coin</a>
</p>

<p>
See <a href="http://en.wikipedia.org/wiki/Law_of_large_numbers">Law of Large Numbers</a>
</p>


<div class="figure">
<p><img src="images/coinflip.gif" alt="coinflip.gif" />
</p>
</div>

<p>
File: coinSimulator.hs
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">System.Random</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Control.Monad</span> (replicateM)

<span class="org-comment-delimiter">{-</span>
<span class="org-comment">    0 - tails</span>
<span class="org-comment">    1 - means head</span>

<span class="org-comment">-}</span>

<span class="org-haskell-definition">flipCoin</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">Integer</span>
<span class="org-haskell-definition">flipCoin</span> <span class="org-haskell-operator">=</span> randomRIO (0, 1)

<span class="org-haskell-definition">flipCoinNtimes</span> n <span class="org-haskell-operator">=</span> replicateM n flipCoin

<span class="org-haskell-definition">frequency</span> elem alist <span class="org-haskell-operator">=</span> length <span class="org-haskell-operator">$</span> filter (<span class="org-haskell-operator">==</span>elem) alist

<span class="org-haskell-definition">relativeFreq</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Integer</span> <span class="org-haskell-operator">-&gt;</span> [<span class="org-haskell-type">Integer</span>] <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span>
<span class="org-haskell-definition">relativeFreq</span> elem alist <span class="org-haskell-operator">=</span> 
    fromIntegral (frequency elem alist) <span class="org-haskell-operator">/</span> fromIntegral (length alist)

<span class="org-haskell-definition">simulateCoinToss</span> ntimes <span class="org-haskell-operator">=</span>  <span class="org-haskell-keyword">do</span>
    series <span class="org-haskell-operator">&lt;-</span> (flipCoinNtimes  ntimes)
    <span class="org-haskell-keyword">let</span> counts <span class="org-haskell-operator">=</span> map (flip frequency series)   [0, 1]
    <span class="org-haskell-keyword">let</span> freqs <span class="org-haskell-operator">=</span> map (flip relativeFreq series) [0, 1]
    return (freqs, counts)

<span class="org-haskell-definition">showSimulation</span> ntimes <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    result <span class="org-haskell-operator">&lt;-</span> simulateCoinToss ntimes
    <span class="org-haskell-keyword">let</span> p_tails <span class="org-haskell-operator">=</span> (fst result) <span class="org-haskell-operator">!!</span> 0
    <span class="org-haskell-keyword">let</span> p_heads <span class="org-haskell-operator">=</span> (fst result) <span class="org-haskell-operator">!!</span> 1

    <span class="org-haskell-keyword">let</span> n_tails <span class="org-haskell-operator">=</span> (snd result) <span class="org-haskell-operator">!!</span> 0
    <span class="org-haskell-keyword">let</span> n_heads <span class="org-haskell-operator">=</span> (snd result) <span class="org-haskell-operator">!!</span> 1

    <span class="org-haskell-keyword">let</span> tosses <span class="org-haskell-operator">=</span> n_tails <span class="org-haskell-operator">+</span> n_heads
    <span class="org-haskell-keyword">let</span> p_error <span class="org-haskell-operator">=</span> abs(p_tails <span class="org-haskell-operator">-</span> p_heads)

    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"Number of tosses : "</span> <span class="org-haskell-operator">++</span> show(tosses)
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"The number of tails is : "</span> <span class="org-haskell-operator">++</span> show(n_tails)        
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"The number of heads is : "</span> <span class="org-haskell-operator">++</span> show(n_heads)
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"The % of tails is : "</span> <span class="org-haskell-operator">++</span> show(100.0<span class="org-haskell-operator">*</span>p_tails)
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"The % of heads is :"</span> <span class="org-haskell-operator">++</span> show(100.0<span class="org-haskell-operator">*</span>p_heads)
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"The %erro is : "</span>  <span class="org-haskell-operator">++</span> show(100<span class="org-haskell-operator">*</span>p_error)
    putStrLn <span class="org-string">"\n-------------------------------------"</span>
</pre>
</div>


<pre class="example">
&gt; :r
[1 of 1] Compiling Main             ( coinSimulator.hs, interpreted )
Ok, modules loaded: Main.
&gt; 

&gt; :t simulateCoinToss 
simulateCoinToss :: Int -&gt; IO ([Double], [Int])
&gt; 

&gt; :t showSimulation 
showSimulation :: Int -&gt; IO ()
&gt; 


&gt; simulateCoinToss 30
([0.5666666666666667,0.43333333333333335],[17,13])
&gt; 
&gt; simulateCoinToss 50
([0.56,0.44],[28,22])
&gt; 
&gt; simulateCoinToss 100
([0.46,0.54],[46,54])
&gt; 
&gt; simulateCoinToss 1000
([0.491,0.509],[491,509])
&gt; 

&gt; mapM_ showSimulation [1000, 10000, 100000, 1000000]
Number of tosses : 1000
The number of tails is : 492
The number of heads is : 508
The % of tails is : 49.2
The % of heads is :50.8
The %erro is : 1.6000000000000014

-------------------------------------
Number of tosses : 10000
The number of tails is : 4999
The number of heads is : 5001
The % of tails is : 49.99
The % of heads is :50.01
The %erro is : 1.9999999999997797e-2

-------------------------------------
Number of tosses : 100000
The number of tails is : 49810
The number of heads is : 50190
The % of tails is : 49.81
The % of heads is :50.19
The %erro is : 0.38000000000000256

-------------------------------------
Number of tosses : 1000000
The number of tails is : 499878
The number of heads is : 500122
The % of tails is : 49.9878
The % of heads is :50.01219999999999
The %erro is : 2.4399999999996647e-2

-------------------------------------
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Vectors</h3>
<div class="outline-text-3" id="text-1-5">
<p>
<b>Dot Product of Two Vectors / Scalar Product</b>
</p>

<ul class="org-ul">
<li>v1.v2 = (x1, y1, z1) . (x2, y2, z2) = x1.y1 + y1.y2 + z2.z1
</li>
<li>v1.v2 = Σai.bi
</li>
</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> dotp v1 v2 <span class="org-haskell-operator">=</span> sum ( zipWith (<span class="org-haskell-operator">*</span>) v1 v2 )   <span class="org-haskell-operator">-</span> <span class="org-haskell-constructor">With</span> <span class="org-haskell-constructor">Parenthesis</span>
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> dotp v1 v2 <span class="org-haskell-operator">=</span> sum <span class="org-haskell-operator">$</span> zipWith (<span class="org-haskell-operator">*</span>) v1 v2     <span class="org-haskell-operator">-</span> <span class="org-haskell-constructor">Without</span> <span class="org-haskell-constructor">Parenthesis</span> with <span class="org-haskell-operator">$</span> operator

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">dotp</span> [1.23, 33.44, 22.23, 40] [23, 10, 44, 12]
1820.81
</pre>
</div>

<p>
<b>Norm of a Vector</b>
</p>

<ul class="org-ul">
<li>norm = sqrt( Σxi^2)
</li>
</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> norm vector <span class="org-haskell-operator">=</span> (sqrt <span class="org-haskell-operator">.</span> sum) (map (<span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x<span class="org-haskell-operator">^</span>2) vector)

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">norm</span> [1, 2, 3, 4, 5]
7.416198487095663

<span class="org-comment-delimiter">-- </span><span class="org-comment">Vector norm in multiple line statements in GHCI interactive shell</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>{
<span class="org-haskell-operator">|</span> <span class="org-haskell-keyword">let</span> {
<span class="org-haskell-operator">|</span>      norm2 vec <span class="org-haskell-operator">=</span>  sqrt(sum_squares)
<span class="org-haskell-operator">|</span>      <span class="org-haskell-keyword">where</span> 
<span class="org-haskell-operator">|</span>      sum_squares <span class="org-haskell-operator">=</span> sum(map square vec)
<span class="org-haskell-operator">|</span>      square x <span class="org-haskell-operator">=</span> x<span class="org-haskell-operator">*</span>x
<span class="org-haskell-operator">|</span>      }
<span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">:</span>}
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">norm2</span> [1, 2, 3, 4, 5]
7.416198487095663
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
<b>Linspace and Range Matlab Function</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">linspace</span> d1 d2 n <span class="org-haskell-operator">=</span> [d1 <span class="org-haskell-operator">+</span> i<span class="org-haskell-operator">*</span>step <span class="org-haskell-operator">|</span> i <span class="org-haskell-operator">&lt;-</span> [0<span class="org-haskell-operator">..</span>n<span class="org-haskell-operator">-</span>1] ]
    <span class="org-haskell-keyword">where</span> 
    step <span class="org-haskell-operator">=</span> (d2 <span class="org-haskell-operator">-</span> d1)<span class="org-haskell-operator">/</span>(n<span class="org-haskell-operator">-</span>1)


<span class="org-haskell-definition">range</span> start stop step <span class="org-haskell-operator">=</span>  [start <span class="org-haskell-operator">+</span> i<span class="org-haskell-operator">*</span>step <span class="org-haskell-operator">|</span> i <span class="org-haskell-operator">&lt;-</span> [0<span class="org-haskell-operator">..</span>n] ]
    <span class="org-haskell-keyword">where</span>
    n <span class="org-haskell-operator">=</span> floor((stop <span class="org-haskell-operator">-</span> start)<span class="org-haskell-operator">/</span>step)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Tax Brackets</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Progressive Income Tax Calculation
</p>

<p>
Credits: <a href="http://ayende.com/blog/108545/the-tax-calculation-challenge">Ayend - Tax Challange</a>
</p>

<p>
The following table is the current tax rates in Israel:
</p>


<pre class="example">
                        Tax Rate
Up      to 5,070        10%
5,071   up to 8,660     14%
8,661   up to 14,070    23%
14,071  up to 21,240    30%
21,241  up to 40,230    33%
Higher  than 40,230     45%
</pre>


<p>
Here are some example answers:
</p>
<pre class="example">
5,000 –&gt; 500
5,800 –&gt; 609.2
9,000 –&gt; 1087.8
15,000 –&gt; 2532.9
50,000 –&gt; 15,068.1
</pre>

<p>
This problem is a bit tricky because the tax rate doesn’t apply to the 
whole sum, only to the part that is within the current rate.
</p>

<p>
A progressive tax system is a way to calculate a tax for a given price 
using brackets each taxed separately using its rate. The french tax on 
revenues is a good example of a progressive tax system.
</p>

<pre class="example">
To calculate his taxation, John will have to do this calculation 
(see figure on left):

= (10,000 x 0.105) + (35,000 x 0.256) + (5,000 x 0.4)
= 1,050 + 8,960 + 2,000
= 12,010
 
John will have to pay $ 12,010

If John revenues was below some bracket definition (take $ 25,000 for 
example), only the last bracket containing the remaining amount to be 
taxed is applied :

= (10,000 x 0.105) + (15,000 x 0.256)

Here nothing is taxed in the last bracket range at rate 40.
</pre>

<p>
Solution:
</p>

<div class="org-src-container">

<pre class="src src-haskell">(<span class="org-haskell-definition">|&gt;</span>) x f <span class="org-haskell-operator">=</span> f x
(<span class="org-haskell-definition">|&gt;&gt;</span>) x f <span class="org-haskell-operator">=</span> map f x
<span class="org-haskell-definition">joinf</span> functions element <span class="org-haskell-operator">=</span> map (<span class="org-haskell-operator">$</span> element) functions

<span class="org-comment-delimiter">-- </span><span class="org-comment">Infinite number</span>
<span class="org-haskell-definition">above</span> <span class="org-haskell-operator">=</span> 1e30 

<span class="org-haskell-definition">pairs</span> xs <span class="org-haskell-operator">=</span> zip xs (tail xs)

<span class="org-comment-delimiter">{- </span>
<span class="org-comment">    Tax rate function - Calculates the net tax rate in %</span>

<span class="org-comment">    taxrate = 100 *  tax / (gross revenue)</span>

<span class="org-comment">-}</span>
<span class="org-haskell-definition">taxrate</span> taxfunction income <span class="org-haskell-operator">=</span> 100.0<span class="org-haskell-operator">*</span>(taxfunction income)<span class="org-haskell-operator">/</span>income

<span class="org-haskell-definition">progressivetax</span> <span class="org-haskell-operator">::</span> [[<span class="org-haskell-type">Double</span>]] <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span>
<span class="org-haskell-definition">progressivetax</span> taxtable income <span class="org-haskell-operator">=</span> amount
            <span class="org-haskell-keyword">where</span> 
            rates <span class="org-haskell-operator">=</span> taxtable <span class="org-haskell-operator">|&gt;&gt;</span> (<span class="org-haskell-operator">!!</span>1) <span class="org-haskell-operator">|&gt;&gt;</span> (<span class="org-haskell-operator">/</span>100.0)  <span class="org-haskell-operator">|&gt;</span> tail
            levels <span class="org-haskell-operator">=</span> taxtable <span class="org-haskell-operator">|&gt;&gt;</span> (<span class="org-haskell-operator">!!</span>0)
            table <span class="org-haskell-operator">=</span> zip3 levels (tail levels) rates            
            amount <span class="org-haskell-operator">=</span> table <span class="org-haskell-operator">|&gt;&gt;</span> frow income <span class="org-haskell-operator">|&gt;</span> takeWhile (<span class="org-haskell-operator">&gt;</span>0) <span class="org-haskell-operator">|&gt;</span> sum

            frow x (xlow, xhigh, rate) <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&gt;</span> xhigh <span class="org-haskell-operator">=</span> (xhigh<span class="org-haskell-operator">-</span>xlow)<span class="org-haskell-operator">*</span>rate 
                                       <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> (x<span class="org-haskell-operator">-</span>xlow)<span class="org-haskell-operator">*</span>rate   
<span class="org-haskell-definition">taxsearch</span> taxtable value <span class="org-haskell-operator">=</span> result        
        <span class="org-haskell-keyword">where</span>
        rows <span class="org-haskell-operator">=</span> takeWhile (<span class="org-haskell-operator">\</span>row <span class="org-haskell-operator">-&gt;</span> fst row <span class="org-haskell-operator">!!</span> 0 <span class="org-haskell-operator">&lt;=</span> value) (pairs taxtable)       
        result <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> rows <span class="org-haskell-keyword">of</span> 
                    <span class="org-haskell-constructor">[]</span> <span class="org-haskell-operator">-&gt;</span> taxtable <span class="org-haskell-operator">!!</span> 0
                    xs <span class="org-haskell-operator">-&gt;</span> snd <span class="org-haskell-operator">$</span> last rows

<span class="org-comment-delimiter">{- </span>
<span class="org-comment">   This is useful for Brazil income tax calculation</span>

<span class="org-comment">  [(Gross Salary  &#8211; Deduction - Social Security ) &#8226; Aliquot &#8211; Deduction] = IRRF </span>
<span class="org-comment">  [(Sal&#225;rio Bruto &#8211; Dependentes &#8211; INSS) &#8226; Al&#237;quota &#8211; Dedu&#231;&#227;o] =</span>

<span class="org-comment">-}</span>
<span class="org-haskell-definition">incometax</span> taxtable income  <span class="org-haskell-operator">=</span> amount<span class="org-comment-delimiter">--</span><span class="org-comment">(tax, aliquot, discount)</span>
                <span class="org-haskell-keyword">where</span>

                row <span class="org-haskell-operator">=</span> taxsearch taxtable income                
                aliquot <span class="org-haskell-operator">=</span> row <span class="org-haskell-operator">!!</span> 1
                discount <span class="org-haskell-operator">=</span> row <span class="org-haskell-operator">!!</span> 2                
                amount <span class="org-haskell-operator">=</span> income<span class="org-haskell-operator">*</span>(aliquot<span class="org-haskell-operator">/</span>100.0) <span class="org-haskell-operator">-</span> discount

<span class="org-comment-delimiter">{- </span><span class="org-comment">Progressive Tax System -}</span>
<span class="org-haskell-definition">israeltaxbrackets</span> <span class="org-haskell-operator">=</span> [
    [0,          0],
    [ 5070.0, 10.0],
    [ 8660.0, 14.0],
    [14070.0, 23.0],
    [21240.0, 30.0],
    [40230.0, 33.0],
    [above  , 45.0]
    ]                    

<span class="org-haskell-definition">taxOfIsrael</span>     <span class="org-haskell-operator">=</span> progressivetax israeltaxbrackets
<span class="org-haskell-definition">taxRateOfIsrael</span> <span class="org-haskell-operator">=</span> taxrate taxOfIsrael

<span class="org-haskell-definition">braziltaxbrackets</span> <span class="org-haskell-operator">=</span> [
    [1787.77,    0,   0.00],
    [2679.29,  7.5, 134.48],
    [3572.43, 15.0, 335.03],
    [4463.81, 22.5, 602.96],
    [above,    27.5, 826.15]
   ]


<span class="org-haskell-definition">taxOfBrazil</span> <span class="org-haskell-operator">=</span> incometax braziltaxbrackets
<span class="org-haskell-definition">taxRateOfBrazil</span> <span class="org-haskell-operator">=</span> taxrate  taxOfBrazil



<span class="org-comment-delimiter">{- </span>
<span class="org-comment">    Unit test of a function of numerical input and output.</span>

<span class="org-comment">    input       - Unit test case values             [t1, t2, t2, e5]</span>
<span class="org-comment">    expected    - Expected value of each test case  [e1, e2, e3, e4]</span>
<span class="org-comment">    tol         - Tolerance 1e-3 typical value </span>
<span class="org-comment">    f           - Function:                         error_i = abs(e_i-t_i)</span>

<span class="org-comment">    Returns true if in all test cases  error_i &lt; tol</span>
<span class="org-comment">-}</span>
<span class="org-haskell-definition">testCaseNumeric</span> <span class="org-haskell-operator">::</span> (<span class="org-haskell-type">Num</span> a, <span class="org-haskell-type">Ord</span> a) <span class="org-haskell-operator">=&gt;</span> [a1] <span class="org-haskell-operator">-&gt;</span> [a] <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> (a1 <span class="org-haskell-operator">-&gt;</span> a) <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Bool</span>
<span class="org-haskell-definition">testCaseNumeric</span> input expected tol f <span class="org-haskell-operator">=</span> all (<span class="org-haskell-operator">\</span>t <span class="org-haskell-operator">-&gt;</span> t <span class="org-haskell-operator">&amp;&amp;</span> <span class="org-haskell-constructor">True</span>) ( zipWith (<span class="org-haskell-operator">\</span>x y <span class="org-haskell-operator">-&gt;</span> abs(x<span class="org-haskell-operator">-</span>y) <span class="org-haskell-operator">&lt;</span> tol) (map f input) expected )

<span class="org-haskell-definition">testIsraelTaxes</span> <span class="org-haskell-operator">=</span> testCaseNumeric  
    [5000, 5800, 9000, 15000, 50000]
    [500.0,609.2,1087.8,2532.9,15068.1]
    1e-3 taxOfIsrael

<span class="org-haskell-operator">&gt;</span> testIsraelTaxes 
<span class="org-haskell-constructor">True</span>
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">taxOfIsrael</span> 5000
500.0
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">taxOfIsrael</span> 5800
609.2
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">taxOfIsrael</span> 1087.8
108.78
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">taxOfIsrael</span> 15000.0
2532.9
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">taxOfIsrael</span> 50000.0
15068.1
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">taxRateOfIsrael</span> 5000
10.0
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">taxRateOfIsrael</span> 5800
10.50344827586207
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">taxRateOfIsrael</span> 15000
16.886
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">taxRateOfIsrael</span> 50000
30.1362
</pre>
</div>

<p>
Sources: 
</p>
<ul class="org-ul">
<li><a href="http://ayende.com/blog/108545/the-tax-calculation-challenge">http://ayende.com/blog/108545/the-tax-calculation-challenge</a>
</li>
<li><a href="http://gghez.com/c-net-implementation-of-a-progressive-tax-system/">http://gghez.com/c-net-implementation-of-a-progressive-tax-system/</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> Small DSL Domain Specific Language</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Simple DSL for describing cups of Starbucks coffee and computing prices (in dollars). 
Example taken from: <a href="http://www.fssnip.net/9w">http://www.fssnip.net/9w</a> 
</p>


<p>
starbuck_dsl.hs
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Size</span>  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Tall</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Grande</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Venti</span>
            <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Enum</span>, <span class="org-haskell-constructor">Read</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Ord</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Drink</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Latte</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Cappuccino</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Mocha</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Americano</span>            
            <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Enum</span>, <span class="org-haskell-constructor">Read</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Ord</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Extra</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Shot</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Syrup</span>
            <span class="org-haskell-keyword">deriving</span> (<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Enum</span>, <span class="org-haskell-constructor">Read</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Ord</span>)

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Cup</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Cup</span> {
                cupDrink <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Drink</span>,
                cupSize  <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Size</span>,
                cupExtra <span class="org-haskell-operator">::</span> [<span class="org-haskell-type">Extra</span>]         
               }
               <span class="org-haskell-keyword">deriving</span>(<span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Read</span>)

<span class="org-comment-delimiter">{-</span>
<span class="org-comment"> -                  Table in the format:</span>
<span class="org-comment"> -                 -------------------</span>
<span class="org-comment"> -                  tall, grande, venti </span>
<span class="org-comment"> -    Latte         p00   p01     p02</span>
<span class="org-comment"> -    Cappuccino    p10   p11     p12</span>
<span class="org-comment"> -    Mocha         p20   p21     p22</span>
<span class="org-comment"> -    Amaericano    p30   p31     p32</span>
<span class="org-comment"> -}</span>

<span class="org-haskell-definition">table</span> <span class="org-haskell-operator">=</span> [
    [2.69, 3.19, 3.49],
    [2.69, 3.19, 3.49],
    [2.99, 3.49, 3.79],
    [1.89, 2.19, 2.59]
    ]    


<span class="org-haskell-definition">extraPrice</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Extra</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Double</span>
<span class="org-haskell-definition">extraPrice</span> <span class="org-haskell-constructor">Syrup</span> <span class="org-haskell-operator">=</span> 0.59
<span class="org-haskell-definition">extraPrice</span> <span class="org-haskell-constructor">Shot</span>  <span class="org-haskell-operator">=</span> 0.39

<span class="org-haskell-definition">priceOfcup</span> cup <span class="org-haskell-operator">=</span>  baseprice <span class="org-haskell-operator">+</span> extraprice
            <span class="org-haskell-keyword">where</span>
            drinkrow <span class="org-haskell-operator">=</span> table <span class="org-haskell-operator">!!</span>  fromEnum  (cupDrink cup)
            baseprice   <span class="org-haskell-operator">=</span> drinkrow <span class="org-haskell-operator">!!</span>  fromEnum  (cupSize cup)
            extraprice <span class="org-haskell-operator">=</span> sum <span class="org-haskell-operator">$</span> map extraPrice (cupExtra cup)



<span class="org-comment-delimiter">{- </span><span class="org-comment">Constructor of Cup -}</span>
<span class="org-haskell-definition">cupOf</span> drink size extra <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Cup</span> { 
                             cupSize <span class="org-haskell-operator">=</span> size, 
                             cupDrink <span class="org-haskell-operator">=</span> drink, 
                             cupExtra <span class="org-haskell-operator">=</span> extra}

<span class="org-haskell-definition">drink_options</span> <span class="org-haskell-operator">=</span> [ <span class="org-haskell-constructor">Latte</span>, <span class="org-haskell-constructor">Cappuccino</span>, <span class="org-haskell-constructor">Mocha</span>, <span class="org-haskell-constructor">Americano</span>]
<span class="org-haskell-definition">size_options</span>  <span class="org-haskell-operator">=</span> [ <span class="org-haskell-constructor">Tall</span>, <span class="org-haskell-constructor">Grande</span>, <span class="org-haskell-constructor">Venti</span>]  
<span class="org-haskell-definition">extra_options</span> <span class="org-haskell-operator">=</span> [<span class="org-haskell-constructor">[]</span>, [<span class="org-haskell-constructor">Shot</span>], [<span class="org-haskell-constructor">Syrup</span>], [<span class="org-haskell-constructor">Shot</span>, <span class="org-haskell-constructor">Syrup</span>]]

<span class="org-haskell-definition">cup_combinations</span> <span class="org-haskell-operator">=</span>  
            [ cupOf drink size extra <span class="org-haskell-operator">|</span> drink <span class="org-haskell-operator">&lt;-</span> drink_options, size <span class="org-haskell-operator">&lt;-</span> size_options, extra <span class="org-haskell-operator">&lt;-</span> extra_options]
</pre>
</div>

<p>
Example:
</p>


<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-constructor">:</span>load starbucks_dsl<span class="org-haskell-operator">.</span>hs 
[1 <span class="org-haskell-keyword">of</span> 1] <span class="org-haskell-constructor">Compiling</span> <span class="org-haskell-constructor">Main</span>             ( starbucks_dsl<span class="org-haskell-operator">.</span>hs, interpreted )
<span class="org-haskell-constructor">Ok</span>, modules loaded<span class="org-haskell-constructor">:</span> Main.
<span class="org-haskell-operator">&gt;</span> 
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> myCup <span class="org-haskell-operator">=</span> cupOf <span class="org-haskell-constructor">Latte</span> <span class="org-haskell-constructor">Venti</span> [<span class="org-haskell-constructor">Syrup</span>]
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> price <span class="org-haskell-operator">=</span> priceOfcup myCup 
<span class="org-haskell-operator">&gt;</span> myCup 
<span class="org-haskell-constructor">Cup</span> {cupDrink <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Latte</span>, cupSize <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Venti</span>, cupExtra <span class="org-haskell-operator">=</span> [<span class="org-haskell-constructor">Syrup</span>]}
<span class="org-haskell-operator">&gt;</span> price
4.08
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">priceOfcup</span> (cupOf <span class="org-haskell-constructor">Cappuccino</span> <span class="org-haskell-constructor">Tall</span> [<span class="org-haskell-constructor">Syrup</span>, <span class="org-haskell-constructor">Shot</span>])
3.67
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> cups <span class="org-haskell-operator">=</span> [ cupOf <span class="org-haskell-constructor">Americano</span> <span class="org-haskell-constructor">Venti</span> extra <span class="org-haskell-operator">|</span>  extra <span class="org-haskell-operator">&lt;-</span> extra_options]
<span class="org-haskell-operator">&gt;</span> cups
[<span class="org-haskell-constructor">Cup</span> {cupDrink <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Americano</span>, cupSize <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Venti</span>, cupExtra <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">[]</span>},
<span class="org-haskell-constructor">Cup</span> {cupDrink <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Americano</span>, cupSize <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Venti</span>, cupExtra <span class="org-haskell-operator">=</span> [<span class="org-haskell-constructor">Shot</span>]},
<span class="org-haskell-constructor">Cup</span> {cupDrink <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Americano</span>, cupSize <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Venti</span>, cupExtra <span class="org-haskell-operator">=</span> [<span class="org-haskell-constructor">Syrup</span>]},
<span class="org-haskell-constructor">Cup</span> {cupDrink <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Americano</span>, cupSize <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Venti</span>, cupExtra <span class="org-haskell-operator">=</span> [<span class="org-haskell-constructor">Shot</span>,<span class="org-haskell-constructor">Syrup</span>]}]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> prices <span class="org-haskell-operator">=</span> map priceOfcup cups
<span class="org-haskell-operator">&gt;</span> prices
[2.59,2.98,3.1799999999999997,3.57]
<span class="org-haskell-operator">&gt;</span> 

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> cupPrices <span class="org-haskell-operator">=</span> zip cups prices
<span class="org-haskell-operator">&gt;</span> cupPrices
[(<span class="org-haskell-constructor">Cup</span> {cupDrink <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Americano</span>, cupSize <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Venti</span>, cupExtra <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">[]</span>},2.59),
(<span class="org-haskell-constructor">Cup</span> {cupDrink <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Americano</span>, cupSize <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Venti</span>, cupExtra <span class="org-haskell-operator">=</span> [<span class="org-haskell-constructor">Shot</span>]},2.98),
(<span class="org-haskell-constructor">Cup</span> {cupDrink <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Americano</span>, cupSize <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Venti</span>, cupExtra <span class="org-haskell-operator">=</span> [<span class="org-haskell-constructor">Syrup</span>]},3.1799999999999997),
(<span class="org-haskell-constructor">Cup</span> {cupDrink <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Americano</span>, cupSize <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Venti</span>, cupExtra <span class="org-haskell-operator">=</span> [<span class="org-haskell-constructor">Shot</span>,<span class="org-haskell-constructor">Syrup</span>]},3.57)]
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="sec-1-7-0-1" name="sec-1-7-0-1"></a>String Processing<br  /></li></ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: arch</p>
<p class="date">Created: 2017-03-06 seg 12:32</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>