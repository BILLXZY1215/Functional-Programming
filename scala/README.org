#+TITLE: Functional Programming in Scala 

* FP in Scala 
** Overview 
*** Features

Scala is a statically typed, functional, object orientated and
imperative language, or multi-paradigm programming language that runs
in JVM - Java Virtual Machine that allows type-safe programming with
high productivity.

Features: 

 - Interactive - Scala REPL allows the user to do exploratory design and
   test the Java API interactively.

 - Scripting language. Scala has a fast initialization time what makes
   it suitable for scripting.

 - Java Integration. As a JVM language Scala allows reuse of all Java
   libraries and integration with old code bases.

 - Functional:

   - Provides syntax for curried functions

   - _Higher order methods_. Functions can be passed as arguments to methods.

   - _Type Inference_. It frees the developer from declaring typing for
     all values and functions in a similar way to Haskell, although
     Scala requires some type anotations.

   - _Algebraic Data Types_. AGDT is useful for represeting AST -
     Abstract Syntax Trees; write parsers and compilers and perform
     symbolic computations.

   - _Pattern Matching_

   - _Tail Call Optimization_. TCO makes tail-recursive functions not
     consume stack frames avoiding stack overflows.

*** Getting Scala 
*** File Extensions

| Extension | Description                   |
|-----------+-------------------------------|
| .scala    | Scala source code or script   |
| .java     | Java source code              |
|           |                               |
| .class    | Java bytecode or compile code |
| .jar      | Java application              |
|           |                               |
|           |                               |

*** REPL - Scala Shell 

The Scala REPL or Scala shell allows exploratory design and
interactive lerarning about the Java API.

| Command                 | Description                             |
|-------------------------+-----------------------------------------|
| :help                   | Show help                               |
| :paste                  | Paste a block of code and enter Ctrl+D. |
| :past =<path-to-file>=  | Load a file.                            |
| :load =<path-to-file>=  | Load a Scala file into the repl.        |
| :cp   =<path-to-*.jar>= | Load a Jar file into the REPL.          |
| :history                | Show command history                    |
| :quit or Ctrl + c       | Exit REPL                               |
|                         |                                         |

Scala REPL:

[[file:scala/images/scala-repl-shell1.png][file:scala/images/scala-repl-shell1.png]] 

** Basic Syntax 

*Comment* 

#+BEGIN_SRC scala 
// A comment 

/* 
Multiline Comment 

*/

#+END_SRC


*Value (Immutable)*

#+BEGIN_SRC scala 

scala> val x = 10.2323
x: Double = 10.2323

scala> x = 1.5354
<console>:12: error: reassignment to val
       x = 1.5354

scala> val a = "hello world"
a: String = hello world

val s = """Hello world 
Scala 
String
"""

#+END_SRC

*Variable* 

#+BEGIN_SRC scala 

scala> var x = 10.2334
x: Double = 10.2334

scala> x = 4.5
x: Double = 4.5

scala> var s = "Hello"
s: String = Hello

scala> s = "world"
s: String = world

scala> 

#+END_SRC

*Import Java Libraries*

Import namespace java.io

#+BEGIN_SRC scala
scala> import java.io._
import java.io._


#+END_SRC

Import multiple classes

#+BEGIN_SRC scala
scala> import javax.swing.JFrame
import javax.swing.JFrame

scala> import javax.swing.{JFrame, JPanel, JLabel}
import javax.swing.{JFrame, JPanel, JLabel}

scala> val frame = new JFrame("Hello world Scala")

scala> frame.setSize(300, 400)

scala> frame.setVisible(true)

#+END_SRC


or

#+BEGIN_SRC scala
scala> val frame = new javax.swing.JFrame("Hello world Scala")

scala> frame.setSize(300, 400)

scala> frame.setVisible(true)
#+END_SRC

*Method Syntax*

#+BEGIN_SRC scala
scala> Math.log10(1000)
res16: Double = 3.0

scala> Math log10 1000
res17: Double = 3.0

scala> List(1.0, 10.0, 100.0, 1000.0, 10000.0).map(Math.log10)
res20: List[Double] = List(0.0, 1.0, 2.0, 3.0, 4.0)

scala> List(1.0, 10.0, 100.0, 1000.0, 10000.0) map Math.log10
res21: List[Double] = List(0.0, 1.0, 2.0, 3.0, 4.0)


#+END_SRC


** Functions
*** Function Definition 

#+BEGIN_SRC scala 
  def prod(x: Int, y: Int) = x * y

  scala> prod(4, 5)
  res11: Int = 20


  def fun(a: Int, b: Int) = {
    val c = 3 * a + b
    val d = b - a
    c * d // The return value is the last value 
  }

  /** 
     a = 4 and b = 5
     c = 3 * a + b = 3 * 4 + 5 = 17 
     d = b - a     = 5 - 4 = 1

  Return value:
     c * d = 17 * 1 

  --------------- */
  scala> fun(4, 5)
  res8: Int = 17


  def showFiles(path: String) = { 
    val file = new java.io.File(path)
    file.listFiles.foreach(println)
  }

  // Pasting in the REPL 
  scala> def showFiles(path: String) = { 
       |   val file = new java.io.File(path)
       |   file.listFiles.foreach(println)
       | }
  showFiles: (path: String)Unit


  scala> showFiles("/")
  /home
  /var
  /bin
  /usr
  /root
  /Applications
  /proc
  /boot
  /dev
  ... ... 
#+END_SRC


#+BEGIN_SRC scala 

#+END_SRC
*** Anonymous Functions / Lambda Functions or Function Literals 

Simple Anonymous Functions 

#+BEGIN_SRC scala 
scala> val mulBy10 = (x: Int) => x * 10
mulBy10: Int => Int = <function1>

scala> mulBy10(5)
res25: Int = 50

scala> 

scala> val add = (x: Double, y: Double) => x + y
addV1: (Double, Double) => Double = <function2>

scala> add(10, 20)
res26: Double = 30.0

#+END_SRC

Multi line anonymous functions 

#+BEGIN_SRC scala 
  val func = (a: Double, b: Double) => { 
    val m = a * b
    val n = a * a * 3 - 4.5 * b
    (m, n, m + n)
  }

  scala> val func = (a: Double, b: Double) => { 
       |   val m = a * b
       |   val n = a * a * 3 - 4.5 * b
       |   (m, n, m + n)
       | }
  func: (Double, Double) => (Double, Double, Double) = <function2>

  scala> func(3, 5)
  res28: (Double, Double, Double) = (15.0,4.5,19.5)

  scala> func(4, 3)
  res29: (Double, Double, Double) = (12.0,34.5,46.5)

  scala> 

#+END_SRC

*** Curried Functions 


Function in non-curried form (Tuple):

#+BEGIN_SRC scala
scala> def mulxy (x: Int, y: Int) = x * y
mulxy: (x: Int, y: Int)Int

scala> mulxy(3, 4)
res37: Int = 12


scala> List(1, 2, 3, 4, 5).map(mulxy(3, _))
res38: List[Int] = List(3, 6, 9, 12, 15)


scala> List(1, 2, 3, 4, 5).map(mulxy(_, 4))
res39: List[Int] = List(4, 8, 12, 16, 20)

#+END_SRC

Function in Curried Form:

#+BEGIN_SRC scala

scala> def mulxy (x: Int) (y: Int) = x * y
mulxy: (x: Int)(y: Int)Int

scala> mulxy _
res89: Int => (Int => Int) = <function1>

scala> mulxy(3)_
res88: Int => Int = <function1>

scala> mulxy(3)(4)
res90: Int = 12

scala> List(2, 3, 4, 5).map(mulxy(5))
res91: List[Int] = List(10, 15, 20, 25)

scala> List(2, 3, 4, 5) map mulxy(5)
res38: List[Int] = List(10, 15, 20, 25)

#+END_SRC

Curried anonymous functions 

#+BEGIN_SRC scala 
scala> val mulNonCurried = (x: Int, y: Int) => x * y
mulNonCurried: (Int, Int) => Int = <function2>

scala> mulNonCurried(3, 5)
res30: Int = 15


scala> val mulCurried = (x: Int) => (y: Int) => x * y
mulCurried: Int => (Int => Int) = <function1>

scala> mulCurried(5)
res32: Int => Int = <function1>

scala> mulCurried(5)(4)
res33: Int = 20

scala> List(1, 2, 3, 4, 5).map(mulCurried(4))
res34: List[Int] = List(4, 8, 12, 16, 20)

scala> List(1, 2, 3, 4, 5)  map mulCurried(4)
res35: List[Int] = List(4, 8, 12, 16, 20)

#+END_SRC
*** Closures 

#+BEGIN_SRC scala 

  def makeMultiplier(factor: Double) = {
    val m = (factor + 1.0) * factor
    val n = factor / 100.0
    (x: Double) => x * m + n 
  }

  scala> def makeMultiplier(factor: Double) = {
       |   val m = (factor + 1.0) * factor
       |   val n = factor / 100.0
       |   (x: Double) => x * m + n 
       | }
  makeMultiplier: (factor: Double)Double => Double


  scala> val fn1 = makeMultiplier(3.0)
  fn1: Double => Double = <function1>

  scala> val fn2 = makeMultiplier(4.0)
  fn2: Double => Double = <function1>

  scala> fn1(1)
  res40: Double = 12.03

  scala> fn1(2)
  res41: Double = 24.03

  scala> fn2(1)
  res42: Double = 20.04

  scala> fn1(2)
  res43: Double = 24.03



#+END_SRC

*** Function Composition

*Math Composition*

Computes f.compose(g) = f°g (x) = f(g(x))

 - f°g (3) = f(g(3)) = f(2*3) = f(6) = 6 + 10 = 16 ok.


#+BEGIN_SRC
                       f ° g = f(g(x))
    ....................................................
    .  ___________________      ___________________    .
    .  |                 |      |                 |    .
    .  |                 |      |                 |    .
  --+->+ g(x) = x * 2    +-->---+  f(x) = x * 2   +----+-->
 4  .  | g(4) = 8        |  8   |  f(8) = 16      |    . 16
    .  |_________________|      +-----------------+    .
    .                                                  .
    ....................................................

       ................
       .              .
  4 -->+  (f ° g) (x) +--> 16
       .  f(g(x))     .
       ................

#+END_SRC


#+BEGIN_SRC scala
scala> val f = (x: Int) => x + 10
f: Int => Int = <function1>

scala> val g = (x: Int) => x * 2
g: Int => Int = <function1>


scala> val comp1 = f.compose(g)
comp1: Int => Int = <function1>


scala> comp1(3)
res70: Int = 16

scala> List(1, 2, 3, 4, 5).map(comp1)
res71: List[Int] = List(12, 14, 16, 18, 20)

scala>


/// It could also be:

scala> val comp11 = f compose g
comp11: Int => Int = <function1>

scala> List(1, 2, 3, 4, 5).map(comp11)
res72: List[Int] = List(12, 14, 16, 18, 20)

#+END_SRC


*Reverse Composition* (andThen)

 - f.andThen(g) = f >> g = g(f(x))
 - (f andThen g)(4) = (f >> g)(4) = g(f(4)) = g(14) = 28 . Ok.

#+BEGIN_SRC
                       f >> g = g ° f = g(f(x))
    ....................................................
    .   ___________________      ___________________   .
    .  |                 |      |                 |    .
    .  |                 |      |                 |    .
  ---->+ f(x) = x + 10   +-->---+  g(x) = x * 2   +----+-->
 4  .  | f(4) = 14       |  14  |  g(14) = 28     |    . 28
    .  |_________________|      +-----------------+    .
    .                                                  .
    ....................................................


       .................
       .               .
  4 -->+  (f >> g) (x) +--> 28
       .  g(f(x))      .
       .................

#+END_SRC


#+BEGIN_SRC scala
scala> val f = (x: Int) => x + 10
f: Int => Int = <function1>

scala> val g = (x: Int) => x * 2
g: Int => Int = <function1>

scala> val f_rcomp_g = f andThen g
f_rcomp_g: Int => Int = <function1>

scala> f_rcomp_g (4)
res76: Int = 28

// Or
scala> f.andThen(g)(4)
res77: Int = 28

#+END_SRC

*** Higher Order Functions 

#+BEGIN_SRC scala 

  def sumFn1(f: Int => Int, g: Int => Int, x: Int) = f(x) + g(x)

  scala> def sumFn1(f: Int => Int, g: Int => Int) (x: Int) = f(x) + g(x)
  sumFn: (f: Int => Int, g: Int => Int)(x: Int)Int


  scala>  sumFn1(x => x * 4, a => a + 5, 4)
  res46: Int = 25

  scala>  sumFn1(x => x * 4, a => a + 5, 5)
  res47: Int = 30

  scala>  sumFn1(x => x * x, a => a + 5, 5)
  res48: Int = 35


  def sumFn2(f: Int => Int, g: Int => Int) = (x: Int) => f(x) + g(x)

  scala> f1(3)
  res49: Int = 20

  scala> f1(5)
  res50: Int = 30

  scala> val f2 = sumFn2(x => x * x, a => a + a)
  f2: Int => Int = <function1>

  scala> f2(3)
  res51: Int = 15

  scala> f2(5)
  res52: Int = 35



  def iterFiles(fn: String => Unit) = (path: String) => {
    val f = new java.io.File(path)
    f.listFiles().foreach(file => fn(file.toString))
  }

  scala> iterFiles(println)("/")
  /home
  /var
  /bin
  /usr
  /root
  /Applications
  /proc
  /boot
  /dev
    ...

  scala> val showFiles = iterFiles(println)
  showFiles: String => Unit = <function1>


  scala> showFiles("/etc")
  /etc/systemd
  /etc/motd
  /etc/gemrc
  /etc/adobe
  /etc/ld.so.cache
  /etc/environment
  /etc/libreoffice
  /etc/rc_keymaps
  /etc/sensors3.conf
  ... ... 

#+END_SRC
** Imperative Constructs 
*** While loop 

#+BEGIN_SRC scala
  var i = 0
  while (i < 10){
     println ("i = " + i)
     i = i + 1
  }

  scala> var i = 0
  i: Int = 0

  scala> while (i < 10){
       |    println ("i = " + i)
       |    i = i + 1
       | }
  i = 0
  i = 1
  i = 2
  i = 3
  i = 4
  i = 5
  i = 6
  i = 7
  i = 8
  i = 9



#+END_SRC

*** For-loop 

#+BEGIN_SRC scala 
scala> for (i <- 1 to 10) println(i)
1
2
3
4
5
6
7
8
9
10

scala> for (i <- 1 to 10) println("i = " + i)
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10

scala> for (file <- (new java.io.File("/").listFiles)) println(file)
/home
/var
/bin
/usr
/root
/Applications
/proc
/boot
/dev
/opt
/etc
/mnt
/tmp
/run
/desktopfs-pkgs.txt
/lib
/.manjaro-tools
/srv
/lib64
/rootfs-pkgs.txt
/sys
/sbin
/lost+found

#+END_SRC
