#+TITLE: Functional Programming in Scala

* Scala
** Overview
*** Features

Scala is a statically typed, functional, object orientated and
imperative language created by [[https://en.wikipedia.org/wiki/Martin_Odersky][Martin Odersky]] , or multi-paradigm
programming language that runs in JVM - Java Virtual Machine that
allows type-safe programming with high productivity.

Features:

 - _Interactive_ - Scala REPL allows the user to do exploratory design and
   test the Java API interactively.

 - _Scripting language_ Scala has a fast initialization time what makes
   it suitable for scripting.

 - _Java Integration_ As a JVM language Scala allows reuse of all Java
   libraries and integration with old code bases.

 - Multi Paradigm:

   - Imperative

   - Object Orientated

   - Functional

 - Functional Programming Features

   - Lambda function (aka anonymous function) 

   - Provides short syntax for curried functions

   - _Higher order methods_. Functions can be passed as arguments to methods.

   - _Type Inference_. It frees the developer from declaring typing for
     all values and functions in a similar way to Haskell, although
     Scala requires some type anotations.

   - _Algebraic Data Types_. AGDT is useful for represeting AST -
     Abstract Syntax Trees; write parsers and compilers and perform
     symbolic computations.

   - _Pattern Matching_

   - _Tail Call Optimization_. TCO makes tail-recursive functions not
     consume stack frames avoiding stack overflows.

Notes: 

 - Scala is also useful to learn quickly about Java API since it is
   interactive.

*** Getting Scala

See: [[https://www.scala-lang.org/download/][Download | The Scala Programming Language]]

*** File Extensions

| Extension | Description                   |
|-----------+-------------------------------|
| .scala    | Scala source code or script   |
| .java     | Java source code              |
|           |                               |
| .class    | Java bytecode or compile code |
| .jar      | Java application              |
|           |                               |
|           |                               |

** Tooling
*** Overview

| Program       | Description                                                                      |
|---------------+----------------------------------------------------------------------------------|
| *Scala tools* |                                                                                  |
| scala         | Scala REPL or interactive shell like python or ipython.                          |
| scalac        | Scala compiler.                                                                  |
| scaladoc      | Documentation builder similar to Javadoc.                                        |
| sbt           | Simple Building Tool. Or scala building tool similar to Maven, but less verbose. |
|               |                                                                                  |
| *Java tools*  |                                                                                  |
| java          | Java runtime.                                                                    |
| javac         | Java compiler.                                                                   |
| javadoc       | java documentation builder.                                                      |
|               |                                                                                  |
|               |                                                                                  |

*** REPL - Scala Shell
**** REPL Commands

The Scala REPL or Scala shell allows exploratory design and
interactive lerarning about the Java API.

| Command                    | Description                                   |
|----------------------------+-----------------------------------------------|
| :help                      | Show help                                     |
| :paste                     | Paste a block of code and enter Ctrl+D.       |
| :paste =<path-to-file>=    | Load a file.                                  |
| :load =<path-to-file>=     | Load a Scala file into the repl.              |
| :require =<path-to-*.jar>= | Load a Jar file into the REPL.                |
| :history                   | Show command history                          |
| :reset                     | Reset repl to its initial state.              |
| :silent                    | Enable/disable automatic printing of results. |
| :quit or Ctrl + c          | Exit REPL                                     |
|                            |                                               |

Scala REPL:

[[file:images/scala-repl-shell1.png][file:images/scala-repl-shell1.png]]

Example: Load a scala script  in the repl. File: [[file:src/clockDisplayGui.scala][file:src/clockDisplayGui.scala]]

#+BEGIN_SRC scala 
scala> :load clockDisplayGui.scala
Loading clockDisplayGui.scala...
runTimer: (interval: Int, taskFn: () => Unit)java.util.Timer
currentTime: ()String
frame: javax.swing.JFrame = javax.swing.JFrame[frame0,0,0,0x0,invalid,hidden,layout=java.awt.BorderLayout,title=Java Clock App,resizable,normal,defaultCloseOperation=HIDE_ON_CLOSE,rootPane=javax.swing.JRootPane[,0,0,0x0,invalid,layout=javax.swing.JRootPane$RootLayout,alignmentX=0.0,alignmentY=0.0,border=,flags=16777673,maximumSize=,minimumSize=,preferredSize=],rootPaneCheckingEnabled=true]
label: javax.swing.JLabel = javax.swing.JLabel[,0,0,0x0,invalid,alignmentX=0.0,alignmentY=0.0,border=,flags=8388608,maximumSize=,minimumSize=,preferredSize=,defaultIcon=,disabledIcon=,horizontalAlignment=LEADING,horizontalTextPosition=TRAILING,iconTextGap=4,labelFor=,text=,verticalAlignment=CENTER,verticalTextPosition=CENTER]
res0: java.awt.Component = javax.swing.JLabel[,0,0,0x0,invalid,alignmentX=0.0,alignmentY=0.0,border=,flags=8388608,maximumSize=,minimumSize=,preferredSize=,defaultIcon=,disabledIcon=,horizontalAlignment=LEADING,horizontalTextPosition=TRAILING,iconTextGap=4,labelFor=,text=,verticalAlignment=CENTER,verticalTextPosition=CENTER]
res3: java.util.Timer = java.util.Timer@455b6df1

ob_scala_eol

#+END_SRC

**** Running Scala Scripts
     :PROPERTIES:
     :ID:       8fee2473-9ca4-45f5-b316-84febb5dcb1e
     :END:
***** Sample script 

 - file: [[file:src/scalaScript.scala][file:src/scalaScript.scala]]

#+BEGIN_SRC scala :tangle src/scalaScript.scala 
  import javax.swing.{JFrame, JPanel, JTextArea}

  println("Hello world Scala")

  val frame = new JFrame("Sample scala script")
  frame.setSize(300, 400)
  frame.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE)

  val tarea = new JTextArea()
  val scroll = new javax.swing.JScrollPane(tarea)
  frame.add(scroll)
  frame.setVisible(true)

  tarea.append("Hello world Scala Script")
  tarea.append("\nHello world! (en)")
  tarea.append("\nHola mundo!  (es)")
  tarea.append("\nOla mundo!   (pt)")


#+END_SRC

***** Running script from command line: 

#+BEGIN_SRC sh
  $ scala scalaScript.scala 
  Hello world Scala

  ob_scala_eol

#+END_SRC

Screenshot: 

[[file:images/scalaScriptRunning.png][file:images/scalaScriptRunning.png]]

***** Running the script command line with faster initialization. 

 - =scala -save scalaScript.scala= 

It will run the script and compile it to scalaScript.jar that will
speed up the initialization when the scala program is invoked again.

#+BEGIN_SRC sh 
  $ scala -save scalaScript.scala 
  Hello world Scala

  $ file scalaScript.jar 
  scalaScript.jar: Java archive data (JAR)

  $ unzip -l scalaScript.jar 
  Archive:  scalaScript.jar
    Length      Date    Time    Name
  ---------  ---------- -----   ----
         75  2017-06-30 16:02   META-INF/MANIFEST.MF
       1691  2017-06-30 16:02   Main$$anon$1.class
        570  2017-06-30 16:02   Main$.class
        556  2017-06-30 16:02   Main.class
  ---------                     -------
       2892                     4 files

  # Next initialization is faster. 
  $ scala scalaScript.scala 
  Hello world Scala

  ob_scala_eol

  # The generated jar file can be executed directly.
  $ scala scalaScript.jar
  Hello world Scala

  ob_scala_eol

  # It be executed directly with java and Scala runtime library.
  $ java -cp /home/archbox/opt/scala-2.11.8/lib/scala-library.jar:scalaScript.jar Main 
  Hello world Scala

  ob_scala_eol
      
#+END_SRC

***** Running script from scala REPL. 

#+BEGIN_SRC sh 
$ scala
Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_20).
Type in expressions for evaluation. Or try :help.

scala> :paste scalaScript.scala
Pasting file scalaScript.scala...
Hello world Scala

scala> println(tarea.getText())
Hello world Scala Script
Hello world! (en)
Hola mundo!  (es)
Ola mundo!   (pt)

Write something more. 

Scala allows to write apps with GUIs fast!!

Like in Smalltalk, in Scala all objects 
and functions are right at your fingers.

scala> tarea.setText("Hello world Java Swing")

scala> 
#+END_SRC

*** Scalac - Scala compiler 
    :PROPERTIES:
    :ID:       19e4e984-865a-4dd8-be13-7cc406aa2cca
    :END:
**** Sample scala program

 - file: [[file:src/scalaProgram.scala][file:src/scalaProgram.scala]]

#+BEGIN_SRC scala :tangle src/scalaProgram.scala 
  package scalaApp

  import javax.swing.{JFrame, JPanel, JTextArea}

  object Main{

    def main(arrgs: Array[String]){
      println("Hello world Scala")

      val frame = new JFrame("Sample scala script")
      frame.setSize(300, 400)
      frame.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE)

      val tarea = new JTextArea()
      val scroll = new javax.swing.JScrollPane(tarea)
      frame.add(scroll)
      frame.setVisible(true)

      tarea.append("Hello world Scala Script")
      tarea.append("\nHello world! (en)")
      tarea.append("\nHola mundo!  (es)")
      tarea.append("\nOla mundo!   (pt)")

    }
  }

#+END_SRC

**** Compiling  

Compiling: 

#+BEGIN_SRC sh 
# Compile 
$ scalac scalaProgram.scala 

# Inspect generated files.
$ ls scalaApp/
 Main.class  'Main$.class'

$ file scalaApp/Main.class 
scalaApp/Main.class: compiled Java class data, version 50.0 (Java 1.6)
#+END_SRC

Running with scala: 

#+BEGIN_SRC sh 
$ scala scalaApp.Main 
Hello world Scala

#+END_SRC

Running directly with java:

#+BEGIN_SRC sh 
$ java -cp .:/home/archbox/opt/scala-2.11.8/lib/scala-library.jar scalaApp.Main
Hello world Scala
#+END_SRC

Screenshot: 

[[file:images/scalaScriptRunning.png][file:images/scalaScriptRunning.png]]

**** Compiling to a jar file 

Compiling:

#+BEGIN_SRC sh 
  $ scalac scalaProgram.scala -d scalaApp.jar 

  # Inspect generated file.
  $ file scalaApp.jar 
  scalaApp.jar: Java archive data (JAR)

  # View package contents with jar tool.
  $ jar tf scalaApp.jar 
  META-INF/MANIFEST.MF
  scalaApp/Main.class
  scalaApp/Main$.class

  # View package contents with unzip tool.
  $ unzip -l scalaApp.jar 
  Archive:  scalaApp.jar
    Length      Date    Time    Name
  ---------  ---------- -----   ----
         84  2017-06-30 16:50   META-INF/MANIFEST.MF
        586  2017-06-30 16:50   scalaApp/Main.class
       1369  2017-06-30 16:50   scalaApp/Main$.class
  ---------                     -------
       2039                     3 files
#+END_SRC

Running with scala: 

#+BEGIN_SRC sh 
$ scala scalaApp.jar 
Hello world Scala
#+END_SRC

Running with java: 

#+BEGIN_SRC sh 
$ java -cp scalaApp.jar:/home/archbox/opt/scala-2.11.8/lib/scala-library.jar scalaApp.Main
Hello world Scala

#+END_SRC

or 

#+BEGIN_SRC sh 
$ cp /home/archbox/opt/scala-2.11.8/lib/scala-library.jar .
$ java -cp scalaApp.jar:scala-library.jar scalaApp.Main
Hello world Scala
#+END_SRC
**** See also 

 - [[https://docs.oracle.com/javase/tutorial/deployment/jar/appman.html][Setting an Application's Entry Point (The Java™ Tutorials > Deployment > Packaging Programs in JAR Files)]] 

 - [[https://docs.oracle.com/javase/tutorial/deployment/jar/][Lesson: Packaging Programs in JAR Files (The Java™ Tutorials > Deployment)]]

 - [[https://docs.oracle.com/javase/tutorial/deployment/jar/build.html][Creating a JAR File (The Java™ Tutorials > Deployment > Packaging Programs in JAR Files)]]

 - [[http://www.javaworld.com/article/2857714/learn-java/manipulating-jars-wars-and-ears-on-the-command-line.html][Manipulating JARs, WARs, and EARs on the command line | JavaWorld]] 

 - [[https://coderwall.com/p/ssuaxa/how-to-make-a-jar-file-linux-executable][How to make a JAR file Linux executable (Example)]] 

 - [[https://netbeans.org/kb/articles/javase-deploy.html][Packaging and Deploying Desktop Java Applications]]

 - [[http://xmodulo.com/create-desktop-shortcut-launcher-linux.html][How to create desktop shortcut or launcher on Linux - Xmodulo]]

 - [[http://launch4j.sourceforge.net/index.html][Launch4j - Cross-platform Java executable wrapper]] 

** Basic Syntax

*Comment*

#+BEGIN_SRC scala
// A comment

/*
Multiline Comment

*/

/**
  * Documentation comment.
  *
  */

#+END_SRC


*Value*

It is not possible to reassign values.

#+BEGIN_SRC scala

scala> val x = 10.2323
x: Double = 10.2323

scala> x = 1.5354
<console>:12: error: reassignment to val
       x = 1.5354

scala> val a = "hello world"
a: String = hello world

val s = """Hello world
Scala
String
"""

#+END_SRC

*Variable*

Unlike values, variables allow reassignment.

#+BEGIN_SRC scala

scala> var x = 10.2334
x: Double = 10.2334

scala> x = 4.5
x: Double = 4.5

scala> var s = "Hello"
s: String = Hello

scala> s = "world"
s: String = world

scala>

#+END_SRC

*Import Java Libraries*

Import namespace java.io

#+BEGIN_SRC scala
scala> import java.io._
import java.io._


#+END_SRC

Import multiple classes

#+BEGIN_SRC scala
scala> import javax.swing.JFrame
import javax.swing.JFrame

scala> import javax.swing.{JFrame, JPanel, JLabel}
import javax.swing.{JFrame, JPanel, JLabel}

scala> val frame = new JFrame("Hello world Scala")

scala> frame.setSize(300, 400)

scala> frame.setVisible(true)

#+END_SRC


or

#+BEGIN_SRC scala
scala> val frame = new javax.swing.JFrame("Hello world Scala")

scala> frame.setSize(300, 400)

scala> frame.setVisible(true)
#+END_SRC

*Method Syntax*

#+BEGIN_SRC scala
scala> Math.log10(1000)
res16: Double = 3.0

scala> Math log10 1000
res17: Double = 3.0

scala> List(1.0, 10.0, 100.0, 1000.0, 10000.0).map(Math.log10)
res20: List[Double] = List(0.0, 1.0, 2.0, 3.0, 4.0)

scala> List(1.0, 10.0, 100.0, 1000.0, 10000.0) map Math.log10
res21: List[Double] = List(0.0, 1.0, 2.0, 3.0, 4.0)


#+END_SRC

** Functions
*** Function Definition

#+BEGIN_SRC scala
  def prod(x: Int, y: Int) = x * y

  scala> prod(4, 5)
  res11: Int = 20


  def fun(a: Int, b: Int) = {
    val c = 3 * a + b
    val d = b - a
    c * d // The return value is the last value
  }

  /**
     a = 4 and b = 5
     c = 3 * a + b = 3 * 4 + 5 = 17
     d = b - a     = 5 - 4 = 1

  Return value:
     c * d = 17 * 1

  --------------- */
  scala> fun(4, 5)
  res8: Int = 17


  def showFiles(path: String) = {
    val file = new java.io.File(path)
    file.listFiles.foreach(println)
  }

  // Pasting in the REPL
  scala> def showFiles(path: String) = {
       |   val file = new java.io.File(path)
       |   file.listFiles.foreach(println)
       | }
  showFiles: (path: String)Unit


  scala> showFiles("/")
  /home
  /var
  /bin
  /usr
  /root
  /Applications
  /proc
  /boot
  /dev
  ... ...
#+END_SRC


#+BEGIN_SRC scala

#+END_SRC
*** Anonymous Functions / Lambda Functions or Function Literals

Simple Anonymous Functions

#+BEGIN_SRC scala
scala> val mulBy10 = (x: Int) => x * 10
mulBy10: Int => Int = <function1>

scala> mulBy10(5)
res25: Int = 50

scala>

scala> val add = (x: Double, y: Double) => x + y
addV1: (Double, Double) => Double = <function2>

scala> add(10, 20)
res26: Double = 30.0

#+END_SRC

Multi line anonymous functions

#+BEGIN_SRC scala
  val func = (a: Double, b: Double) => {
    val m = a * b
    val n = a * a * 3 - 4.5 * b
    (m, n, m + n)
  }

  scala> val func = (a: Double, b: Double) => {
       |   val m = a * b
       |   val n = a * a * 3 - 4.5 * b
       |   (m, n, m + n)
       | }
  func: (Double, Double) => (Double, Double, Double) = <function2>

  scala> func(3, 5)
  res28: (Double, Double, Double) = (15.0,4.5,19.5)

  scala> func(4, 3)
  res29: (Double, Double, Double) = (12.0,34.5,46.5)

  scala>

#+END_SRC

*** Curried Functions


Function in non-curried form (Tuple):

#+BEGIN_SRC scala
scala> def mulxy (x: Int, y: Int) = x * y
mulxy: (x: Int, y: Int)Int

scala> mulxy(3, 4)
res37: Int = 12


scala> List(1, 2, 3, 4, 5).map(mulxy(3, _))
res38: List[Int] = List(3, 6, 9, 12, 15)


scala> List(1, 2, 3, 4, 5).map(mulxy(_, 4))
res39: List[Int] = List(4, 8, 12, 16, 20)

#+END_SRC

Function in Curried Form:

#+BEGIN_SRC scala

scala> def mulxy (x: Int) (y: Int) = x * y
mulxy: (x: Int)(y: Int)Int

scala> mulxy _
res89: Int => (Int => Int) = <function1>

scala> mulxy(3)_
res88: Int => Int = <function1>

scala> mulxy(3)(4)
res90: Int = 12

scala> List(2, 3, 4, 5).map(mulxy(5))
res91: List[Int] = List(10, 15, 20, 25)

scala> List(2, 3, 4, 5) map mulxy(5)
res38: List[Int] = List(10, 15, 20, 25)

#+END_SRC

Curried anonymous functions

#+BEGIN_SRC scala
scala> val mulNonCurried = (x: Int, y: Int) => x * y
mulNonCurried: (Int, Int) => Int = <function2>

scala> mulNonCurried(3, 5)
res30: Int = 15


scala> val mulCurried = (x: Int) => (y: Int) => x * y
mulCurried: Int => (Int => Int) = <function1>

scala> mulCurried(5)
res32: Int => Int = <function1>

scala> mulCurried(5)(4)
res33: Int = 20

scala> List(1, 2, 3, 4, 5).map(mulCurried(4))
res34: List[Int] = List(4, 8, 12, 16, 20)

scala> List(1, 2, 3, 4, 5)  map mulCurried(4)
res35: List[Int] = List(4, 8, 12, 16, 20)

#+END_SRC
*** Closures
**** Simple closure example

#+BEGIN_SRC scala

  def makeMultiplier(factor: Double) = {
    val m = (factor + 1.0) * factor
    val n = factor / 100.0
    (x: Double) => x * m + n
  }

  scala> def makeMultiplier(factor: Double) = {
       |   val m = (factor + 1.0) * factor
       |   val n = factor / 100.0
       |   (x: Double) => x * m + n
       | }
  makeMultiplier: (factor: Double)Double => Double


  scala> val fn1 = makeMultiplier(3.0)
  fn1: Double => Double = <function1>

  scala> val fn2 = makeMultiplier(4.0)
  fn2: Double => Double = <function1>

  scala> fn1(1)
  res40: Double = 12.03

  scala> fn1(2)
  res41: Double = 24.03

  scala> fn2(1)
  res42: Double = 20.04

  scala> fn1(2)
  res43: Double = 24.03



#+END_SRC

**** Stateful functions

Example 1

#+BEGIN_SRC scala
  // Version 1
  //
  def makeIncrementer1() = {
    var counter = 0
    val inc = () => {
      val c   = counter
      counter = counter + 1
      c
    }

    inc
  }

  scala> def makeIncrementer1() = {
       |   var counter = 0
       |   val inc = () => {
       |     val c   = counter
       |     counter = counter + 1
       |     c
       |   }
       |
       |   inc
       | }
  makeIncrementer1: ()() => Int

  scala> val inc = makeIncrementer1()
  inc: () => Int = <function0>

  scala> inc()
  res22: Int = 0

  scala> inc()
  res23: Int = 1

  scala> inc()
  res24: Int = 2

  scala> inc()
  res25: Int = 3

  scala> inc()
  res26: Int = 4


  scala> val inc2 = makeIncrementer1()
  inc2: () => Int = <function0>

  scala> inc2()
  res27: Int = 0

  scala> inc2()
  res28: Int = 1

  scala> inc2()
  res29: Int = 2

  scala> inc2()
  res30: Int = 3

  ... ...


  // Version 2
  //
  def makeIncrementer2() = {
    var counter = 0
    () => {
      val c   = counter
      counter = counter + 1
      c
    }
  }

  scala> def makeIncrementer2() = {
       |   var counter = 0
       |   () => {
       |     val c   = counter
       |     counter = counter + 1
       |     c
       |   }
       | }
  makeIncrementer2: ()() => Int

  scala> val inc3 = makeIncrementer
  makeIncrementer1   makeIncrementer2

  scala> val inc3 = makeIncrementer2()
  inc3: () => Int = <function0>

  scala> inc3()
  res31: Int = 0

  scala> inc3()
  res32: Int = 1

  scala> inc3()
  res33: Int = 2

  scala> val inc4 = makeIncrementer2()
  inc4: () => Int = <function0>

  scala> inc4()
  res34: Int = 0

  scala> inc4()
  res35: Int = 1

  scala> inc4()
  res36: Int = 2

  ...
#+END_SRC

Example 2

#+BEGIN_SRC scala

  def makeCounter() = {
    var counter = 0

    val inc = () => {
      val c = counter
      counter = counter + 1
      c
    }

    val dec = () => {
      val c = counter
      counter = counter - 1
      c
    }

    (inc, dec)
  }

  scala> def makeCounter() = {
       |   var counter = 0
       |
       |   val inc = () => {
       |     val c = counter
       |     counter = counter + 1
       |     c
       |   }
       |
       |   val dec = () => {
       |     val c = counter
       |     counter = counter - 1
       |     c
       |   }
       |
       |   (inc, dec)
       | }
  makeCounter: ()(() => Int, () => Int)

  scala> val (inc, dec) = makeCounter()
  inc: () => Int = <function0>
  dec: () => Int = <function0>

  scala> inc()
  res48: Int = 0

  scala> inc()
  res49: Int = 1

  scala> inc()
  res50: Int = 2

  scala> dec()
  res51: Int = 3

  scala> dec()
  res52: Int = 2

  scala> dec()
  res53: Int = 1

  scala> dec()
  res54: Int = 0

  scala> inc()
  res55: Int = -1

  scala> inc()
  res56: Int = 0

  scala> inc()
  res57: Int = 1


#+END_SRC

**** Emulating Objects with closures

#+BEGIN_SRC scala

  // Record of functions
  //
  case class Counter(
        increment: () => Unit
       ,decrement: () => Unit
       ,get:       () => Int
  )

  // The internal state counter can only be accessed using the "methods" or
  // functions increment, decrement and get.
  //
  def newCounter(init: Int) = {
    var counter = init
    Counter(
         () => { counter = counter + 1}
        ,() => { counter = counter - 1}
        ,() => counter
     )
  }

  scala> val c = newCounter(0)
  c: Counter = Counter(<function0>,<function0>,<function0>)

  scala> c.increment _
  res1: () => () => Unit = <function0>

  scala> c.decrement _
  res2: () => () => Unit = <function0>

  scala> c.get
  get   getClass

  scala> c.get _
  res3: () => () => Int = <function0>

  scala> c.get()
  res11: Int = 0

  scala> c.increment()

  scala> c.get()
  res13: Int = 1

  scala> c.increment()

  scala> c.get()
  res15: Int = 2

  scala> c.increment() ; c.get()
  res16: Int = 3

  scala> c.increment() ; c.get()
  res17: Int = 4

  scala> c.increment() ; c.get()
  res18: Int = 5

  scala> c.decrement() ; c.get()
  res19: Int = 4

  scala> c.decrement() ; c.get()
  res20: Int = 3

  scala> c.decrement() ; c.get()
  res21: Int = 2
#+END_SRC
*** Function Composition

*Math Composition*

Computes f.compose(g) = f°g (x) = f(g(x))

 - f°g (3) = f(g(3)) = f(2*3) = f(6) = 6 + 10 = 16 ok.


#+BEGIN_SRC
                       f ° g = f(g(x))
    ....................................................
    .  ___________________      ___________________    .
    .  |                 |      |                 |    .
    .  |                 |      |                 |    .
  --+->+ g(x) = x * 2    +-->---+  f(x) = x + 10  +----+-->
 4  .  | g(4) = 8        |  8   |  f(8) = 18      |    . 18
    .  |_________________|      +-----------------+    .
    .                                                  .
    ....................................................

       ................
       .              .
  4 -->+  (f ° g) (x) +--> 18
       .  f(g(x))     .
       ................

#+END_SRC


#+BEGIN_SRC scala
scala> val f = (x: Int) => x + 10
f: Int => Int = <function1>

scala> val g = (x: Int) => x * 2
g: Int => Int = <function1>


scala> val comp1 = f.compose(g)
comp1: Int => Int = <function1>


scala> comp1(3)
res70: Int = 16

scala> List(1, 2, 3, 4, 5).map(comp1)
res71: List[Int] = List(12, 14, 16, 18, 20)

scala>


/// It could also be:

scala> val comp11 = f compose g
comp11: Int => Int = <function1>

scala> List(1, 2, 3, 4, 5).map(comp11)
res72: List[Int] = List(12, 14, 16, 18, 20)

#+END_SRC


*Reverse Composition* (andThen)

 - f.andThen(g) = f >> g = g(f(x))
 - (f andThen g)(4) = (f >> g)(4) = g(f(4)) = g(14) = 28 . Ok.

#+BEGIN_SRC
                       f >> g = g ° f = g(f(x))
    ....................................................
    .   ___________________      ___________________   .
    .  |                 |      |                 |    .
    .  |                 |      |                 |    .
  ---->+ f(x) = x + 10   +-->---+  g(x) = x * 2   +----+-->
 4  .  | f(4) = 14       |  14  |  g(14) = 28     |    . 28
    .  |_________________|      +-----------------+    .
    .                                                  .
    ....................................................


       .................
       .               .
  4 -->+  (f >> g) (x) +--> 28
       .  g(f(x))      .
       .................

#+END_SRC


#+BEGIN_SRC scala
scala> val f = (x: Int) => x + 10
f: Int => Int = <function1>

scala> val g = (x: Int) => x * 2
g: Int => Int = <function1>

scala> val f_rcomp_g = f andThen g
f_rcomp_g: Int => Int = <function1>

scala> f_rcomp_g (4)
res76: Int = 28

// Or
scala> f.andThen(g)(4)
res77: Int = 28

#+END_SRC

*** Higher Order Functions

#+BEGIN_SRC scala

  def sumFn1(f: Int => Int, g: Int => Int, x: Int) = f(x) + g(x)

  scala> def sumFn1(f: Int => Int, g: Int => Int) (x: Int) = f(x) + g(x)
  sumFn: (f: Int => Int, g: Int => Int)(x: Int)Int


  scala>  sumFn1(x => x * 4, a => a + 5, 4)
  res46: Int = 25

  scala>  sumFn1(x => x * 4, a => a + 5, 5)
  res47: Int = 30

  scala>  sumFn1(x => x * x, a => a + 5, 5)
  res48: Int = 35


  def sumFn2(f: Int => Int, g: Int => Int) = (x: Int) => f(x) + g(x)

  scala> f1(3)
  res49: Int = 20

  scala> f1(5)
  res50: Int = 30

  scala> val f2 = sumFn2(x => x * x, a => a + a)
  f2: Int => Int = <function1>

  scala> f2(3)
  res51: Int = 15

  scala> f2(5)
  res52: Int = 35



  def iterFiles(fn: String => Unit) = (path: String) => {
    val f = new java.io.File(path)
    f.listFiles().foreach(file => fn(file.toString))
  }

  scala> iterFiles(println)("/")
  /home
  /var
  /bin
  /usr
  /root
  /Applications
  /proc
  /boot
  /dev
    ...

  scala> val showFiles = iterFiles(println)
  showFiles: String => Unit = <function1>


  scala> showFiles("/etc")
  /etc/systemd
  /etc/motd
  /etc/gemrc
  /etc/adobe
  /etc/ld.so.cache
  /etc/environment
  /etc/libreoffice
  /etc/rc_keymaps
  /etc/sensors3.conf
  ... ...

#+END_SRC
*** Polymorphic Functions

#+BEGIN_SRC scala 
  def identity[A](x: A) = x

  scala> def identity[A](x: A) = x
  identity: [A](x: A)A

  scala> identity(100)
  res4: Int = 100

  scala> identity(Some(300))
  res5: Some[Int] = Some(300)

  scala> identity("Hello world")
  res6: String = Hello world


  def constantly[A, B](a: A) = (b: B) => a

  scala> constantly(100)
  res7: Any => Int = <function1>

  scala> constantly(100)("Hello")
  res8: Int = 100

  scala> constantly(100)("world")
  res9: Int = 100

  scala> constantly(100)(Some(400))
  res10: Int = 100

  scala> def show[A](a: A) = a.toString
  show: [A](a: A)String


  scala> show(340.343)
  res12: String = 340.343

  scala> show(Some(1000))
  res13: String = Some(1000)

  scala> show(None)
  res14: String = None

#+END_SRC

*** Function with variable number of arguments

#+BEGIN_SRC scala

  def varfun(inputs: String*) = {
    println("I got the parameters: ")
    inputs.foreach(println)
  }

  scala> varfun("Hello", "World", "Scala", "Rocks")
  I got the parameters:
  Hello
  World
  Scala
  Rocks

#+END_SRC

*** Functions with default parameters

#+BEGIN_SRC scala

  /** Free fall speed v(t) = g * t, g in m/s^2 */
  def freeFallSpeed(time: Double, gravity: Double = 9.81) = time * gravity

  scala> freeFallSpeed(1.0)
  res30: Double = 9.81

  scala> freeFallSpeed(2.0)
  res31: Double = 19.62

  scala> freeFallSpeed(2.0, 10.0)
  res32: Double = 20.0

  scala> freeFallSpeed(2.0, 20.0)
  res33: Double = 40.0

  scala> freeFallSpeed(2.0, gravity = 10.0)
  res35: Double = 20.0

  scala> freeFallSpeed(2.0, gravity = 15.0)
  res36: Double = 30.0


#+END_SRC

** Imperative Constructs
*** While loop

#+BEGIN_SRC scala
  var i = 0
  while (i < 10){
     println ("i = " + i)
     i = i + 1
  }

  scala> var i = 0
  i: Int = 0

  scala> while (i < 10){
       |    println ("i = " + i)
       |    i = i + 1
       | }
  i = 0
  i = 1
  i = 2
  i = 3
  i = 4
  i = 5
  i = 6
  i = 7
  i = 8
  i = 9



#+END_SRC

*** For-loop

#+BEGIN_SRC scala
scala> for (i <- 1 to 10) println(i)
1
2
3
4
5
6
7
8
9
10

scala> for (i <- 1 to 10) println("i = " + i)
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10

scala> for (file <- (new java.io.File("/").listFiles)) println(file)
/home
/var
/bin
/usr
/root
/Applications
/proc
/boot
/dev
/opt
/etc
/mnt
/tmp
/run
/desktopfs-pkgs.txt
/lib
/.manjaro-tools
/srv
/lib64
/rootfs-pkgs.txt
/sys
/sbin
/lost+found

#+END_SRC
** Collections
*** Overview

*Collection Hierarchy*

 - Iterable

   - Seq (Sequence)

     - List

       - Fundamental operations: head, tail

     - Vector

       - indexing

     - Array. Mutable array, equivalent to Java Array.

     - String (Seq-like, although not subclass of Seq).

     - Range

   - Sets (Relational algebra). Contains no duplicated element.

   - Map (aka Hashmap, Dictionary or hash-table)


| Scala Collection  | Description                          | Immutable |
|-------------------+--------------------------------------+-----------|
| List              | Linked list                          | Yes       |
| Iterable / Stream | Lazy evaluation                      | Yes       |
| Array             | Random Access by index               | No        |
| Map               | Hash table / Dictionary, Index table | Yes       |
| Set               | Unique items                         | Yes       |
|                   |                                      |           |

*** Immutable Collections
**** Tuples
**** List

*Creating a list*

#+BEGIN_SRC scala
scala> var xs = List(1.0, 2.0, 3.0, 4.0, 5.0, 6.0)
xs: List[Double] = List(1.0, 2.0, 3.0, 4.0, 5.0, 6.0)

#+END_SRC

*Map over a list*

#+BEGIN_SRC scala
scala> xs.map (x => x * 3.0)
res31: List[Double] = List(3.0, 6.0, 9.0, 12.0, 15.0, 18.0)

scala> xs.map (x => x * 3.0).map (x => x + 5)
res33: List[Double] = List(8.0, 11.0, 14.0, 17.0, 20.0, 23.0)

#+END_SRC

*Filter a list*

#+BEGIN_SRC scala
// Filter
//
scala> xs.filter ( x => x < 4.0)
res30: List[Double] = List(1.0, 2.0, 3.0)
#+END_SRC

*Filter a list / reject*

#+BEGIN_SRC scala
// FilterNot - Inverse of filter, reject
//
scala> xs.filterNot (x => x < 4.0)
res80: List[Double] = List(4.0, 5.0, 6.0)
#+END_SRC

*Find a element that matches a predicate function*

#+BEGIN_SRC scala
// Find the first element that satisfies
// a predicate.
//
//
scala> xs.find _
res43: (Double => Boolean) => Option[Double] = <function1>


scala> xs.find (x => x > 4.0)
res42: Option[Double] = Some(5.0)

scala> xs.find (x => x > 14.0)
res44: Option[Double] = None

#+END_SRC

*Test if list is empty*

#+BEGIN_SRC scala
// Test if list is empty
//
scala> xs.isEmpty
res85: Boolean = false
#+END_SRC

*Find the index of an element that satisfies a predicate*

#+BEGIN_SRC scala
// Find the index of an element that satisfies a predicate.
//
//
scala> xs.indexWhere (x =>  x > 4.0)
res116: Int = 4

scala> xs.indexWhere (x =>  x > 14.0)
res117: Int = -1
#+END_SRC

*Count all elements that matches a predicate*

#+BEGIN_SRC scala
// Count all elements greater than 3.0
//
scala> xs.count (x => x > 3.0)
res18: Int = 3
#+END_SRC

*Get max and min elements*

#+BEGIN_SRC scala
// Max and Min elements
//
scala> xs.max
res19: Double = 6.0

scala> xs.min
res20: Double = 1.0
#+END_SRC

*Head (fist) and (last) elements*

#+BEGIN_SRC scala
// Head and tail of a list.

// First element
scala> xs.head
res21: Double = 1.0

// Last element
scala> xs.last
res45: Double = 6.0

#+END_SRC

*Tail*

#+BEGIN_SRC scala
//
// Tail: Remove first element
scala> xs.tail
res22: List[Double] = List(2.0, 3.0, 4.0, 5.0, 6.0)

#+END_SRC

*Reverse a list*

#+BEGIN_SRC scala
scala> xs.reverse
res36: List[Double] = List(6.0, 5.0, 4.0, 3.0, 2.0, 1.0)
#+END_SRC

*Foreach*


#+BEGIN_SRC scala
// Impure Map
//
scala> xs.foreach(println)
1.0
2.0
3.0
4.0
5.0
6.0

scala> xs.foreach(x => println( "x = %.3f".format(x)))
x = 1,000
x = 2,000
x = 3,000
x = 4,000
x = 5,000
x = 6,000
#+END_SRC

*Slice elements*

#+BEGIN_SRC scala
// Select elements x[2],x[3] and x[4]
//
scala> xs.slice(2, 5)
res40: List[Double] = List(3.0, 4.0, 5.0)
#+END_SRC


*Take n elements*

#+BEGIN_SRC scala
scala> xs.take(3)
res68: List[Double] = List(1.0, 2.0, 3.0)
#+END_SRC


*Drop elements*

#+BEGIN_SRC scala
// Drop elements
//
scala> xs.drop _
res66: Int => List[Double] = <function1>

scala> xs.drop (3)
res67: List[Double] = List(4.0, 5.0, 6.0)
#+END_SRC

*Length of a list*

#+BEGIN_SRC scala
// Length of a list
//
scala> xs.length
res69: Int = 6
#+END_SRC

*Sum of all list elements*

#+BEGIN_SRC scala
// Sum of all elements of a list
//
scala> xs.sum
res82: Double = 21.0
#+END_SRC

*Product of all list elements*

#+BEGIN_SRC scala
// Product of all elements of a list
//
scala> xs.product
res83: Double = 720.0
#+END_SRC

*Fold left*

#+BEGIN_SRC scala
// Fold left
//
scala> List(1, 2, 3, 4, 5).foldLeft(0)((acc, x) => 100 * acc + x)
res107: Int = 102030405

scala> List(1, 2, 3, 4, 5).foldLeft(List[Int] ())((acc, x) => x :: acc)
res110: List[Int] = List(5, 4, 3, 2, 1)

#+END_SRC

*Fold right*

#+BEGIN_SRC scala
// Fold right
//
scala> List(1, 2, 3, 4, 5).foldRight(0)((x, acc) => 10 * acc + x)
res111: Int = 54321
#+END_SRC

*Reduce*

#+BEGIN_SRC scala
// Reduce. fold left without initial value of accumulator.
scala> xs.reduce _
res92: ((Double, Double) => Double) => Double = <function1>

scala> xs.reduce ((acc, x) => 10*acc + x)
res95: Double = 123456.0
#+END_SRC

*Max by*

#+BEGIN_SRC scala
// Returns the element for which the projection function has the
// maximun value
//
// In this case: returns the string which its lenght is maximun.
//
scala> var s = List("Hello", "World", "Scala", "is", "amazing")
s: List[String] = List(Hello, World, Scala, is, amazing)

scala> s.maxBy (x => x.length)
res74: String = amazing

#+END_SRC

*Min by*

#+BEGIN_SRC scala

//
//  In this case: returns the string which its length is minimun.
//
scala> s.minBy (x => x.length)
res75: String = is

#+END_SRC

*Sort by*

#+BEGIN_SRC scala
// Sort the string by the length of each string
//
scala> s.sortBy ( x => x.length)
res78: List[String] = List(is, Hello, World, Scala, amazing)

#+END_SRC

*Group by*

#+BEGIN_SRC scala
//  groupBy
// Separate string that have equal number of characters
//
scala> s.groupBy(x => x.length)
res0: scala.collection.immutable.Map[Int,List[String]] = Map(2 -> List(is), 5 -> List(Hello, World, Scala), 7 -> List(amazing))


def fileExtension (filename: String) = {
    val arr = filename.split ('.');

    if (arr.length > 1) {
       arr.apply(1);
    }else{
       "";
    }
}

var files =
List("file1.pdf",
     "file2.doc",
     "dummy.pdf",
     "clojure.jar",
     "document.zip",
     "file3.pdf",
     "scala.jar",
     "manifest.doc",
     "unixBsd"
     )

scala> files.groupBy (fileExtension)
res17: scala.collection.immutable.Map[String,List[String]]
= Map("" -> List(unixBsd), zip -> List(document.zip),
pdf -> List(file1.pdf, dummy.pdf, file3.pdf),
doc -> List(file2.doc, manifest.doc),
jar -> List(clojure.jar, scala.jar))


scala> files.groupBy (fileExtension).foreach(println)
(,List(unixBsd))
(zip,List(document.zip))
(pdf,List(file1.pdf, dummy.pdf, file3.pdf))
(doc,List(file2.doc, manifest.doc))
(jar,List(clojure.jar, scala.jar))

#+END_SRC

*Distinct*

#+BEGIN_SRC scala
// Distinct elements.
//
scala> var a = List(1, 2, 5, 3, 1, 3, 3, 5, 4, 5, 4)
a: List[Int] = List(1, 2, 5, 3, 1, 3, 3, 5, 4, 5, 4)

scala> a.distinct
res88: List[Int] = List(1, 2, 5, 3, 4)

#+END_SRC

**** Maps

Scala Maps are immutable hash tables or dictionaries.
 
 - [[https://www.tutorialspoint.com/scala/scala_maps.htm][Scala Maps]] methods signatures.

#+BEGIN_SRC scala
var capital = Map("US"     -> "Washigton",
                  "France" -> "Paris",
                  "Japan"  -> "Tokyo")

scala> capital("Japan")
res8: String = Tokyo

scala> capital("US")
res9: String = Washigton

scala> capital("USsa")
java.util.NoSuchElementException: key not found: USsa
  at scala.collection.MapLike$class.default(MapLike.scala:228)
  at scala.collection.AbstractMap.default(Map.scala:59)
  at scala.collection.MapLike$class.apply(MapLike.scala:141)
  at scala.collection.AbstractMap.apply(Map.scala:59)
  ... 32 elided


scala> assert(capital("Japan") == "Tokyo")

scala> assert(capital("Japan") == "Tokyo2")
java.lang.AssertionError: assertion failed
  at scala.Predef$.assert(Predef.scala:156)
  ... 32 elided

scala> println(capital("France"))
Paris

scala> println(capital("Japan"))
Tokyo

#+END_SRC


#+BEGIN_SRC scala 
  def getFileExtension(file: String) = {
    val i = file.lastIndexOf('.')
    if ( i > 0)
      file.substring(i+1)
    else
      ""
  }

  // it creates a Map of file extensions as keys and
  // all files with given extension as values
  //
  val fileGroups = {
    (new java.io.File("/etc/"))
      .listFiles()
      .filter(_.isFile)
      .map(_.getPath)
      .groupBy(getFileExtension)
  }


  scala> val fileGroups = {
       |   (new java.io.File("/etc/"))
       |     .listFiles()
       |     .filter(_.isFile)
       |     .map(_.getPath)
       |     .groupBy(getFileExtension)
       | }
  fileGroups: scala.collection.immutable.Map[String,Array[String]] =
  Map("" -> Array(/etc/motd, /etc/gemrc, /etc/environment, /etc/gshadow,
  /etc/shadow-, /etc/fstab, /etc/rpc, /etc/passwd,
  /etc/gnome-vfs-mime-magic, /etc/passwd-, /etc/sudoers,
  /etc/anacrontab, /etc/os-release, /etc/adjtime, /etc/netconfig,
  /etc/inputrc, /etc/timezone, /etc/shadow, /etc/lsb-release,
  /etc/shells, /etc/papersize, /etc/drirc, /etc/hostname, /etc/exports,
  /etc/machine-id, /etc/group-, /etc/nanorc, /etc/hosts, /etc/group,
  /etc/mtab, /etc/securetty, /etc/services, /etc/protocols,
  /etc/gshadow-, /etc/localtime, /etc/issue, /etc/ethertypes,
  /etc/manjaro-release, /etc/yaourtrc, /etc/profile, /etc/printcap,
  /etc/crypttab), backup ->
  Array(/etc/pacman-mirrors.conf.20170402.backup), bash_logout ->
  Array(/etc/bash.bash...  scala>


  // Get all files with cfg extension 
  //
  scala> fileGroups("cfg")
  res113: Array[String] = Array(/etc/vdpau_wrapper.cfg, /etc/rc_maps.cfg)

  // Get all files with conf extension
  //
  cala> fileGroups("conf") res117: Array[String] =
  Array(/etc/sensors3.conf, /etc/pacman.conf, /etc/cpufreq-bench.conf,
  /etc/makepkg.conf, /etc/ld.so.conf, /etc/host.conf, /etc/healthd.conf,
  /etc/ts.conf, /etc/resolvconf.conf, /etc/logrotate.conf,
  /etc/locale.conf, /etc/request-key.conf, /etc/nscd.conf,
  /etc/dnsmasq.conf, /etc/nsswitch.conf, /etc/ntp.conf,
  /etc/updatedb.conf, /etc/dhcpcd.conf, /etc/krb5.conf,
  /etc/openswap.conf, /etc/vconsole.conf, /etc/mkinitcpio.conf,
  /etc/man_db.conf, /etc/mke2fs.conf, /etc/fuse.conf, /etc/asound.conf,
  /etc/mdadm.conf, /etc/pamac.conf, /etc/nfs.conf, /etc/nfsmount.conf,
  /etc/resolv.conf, /etc/gai.conf, /etc/pacman-mirrors.conf,
  /etc/rsyncd.conf)

  scala> fileGroups("wrong")
  java.util.NoSuchElementException: key not found: wrong
    at scala.collection.MapLike$class.default(MapLike.scala:228)
    at scala.collection.AbstractMap.default(Map.scala:59)
    at scala.collection.MapLike$class.apply(MapLike.scala:141)
    at scala.collection.AbstractMap.apply(Map.scala:59)
    ... 32 elided
    
#+END_SRC

Method: .get -> Get a element with given key, returning None if not
element is found.

#+BEGIN_SRC scala
  scala> fileGroups.get("conf")
  res119: Option[Array[String]] = Some([Ljava.lang.String;@4cb04f41)

  scala> fileGroups.get("conf").map(_.toList) res123:
  Option[List[String]] = Some(List(/etc/sensors3.conf, /etc/pacman.conf,
  /etc/cpufreq-bench.conf, /etc/makepkg.conf, /etc/ld.so.conf,
  /etc/host.conf, /etc/healthd.conf, /etc/ts.conf, /etc/resolvconf.conf,
  /etc/logrotate.conf, /etc/locale.conf, /etc/request-key.conf,
  /etc/nscd.conf, /etc/dnsmasq.conf, /etc/nsswitch.conf, /etc/ntp.conf,
  /etc/updatedb.conf, /etc/dhcpcd.conf, /etc/krb5.conf,
  /etc/openswap.conf, /etc/vconsole.conf, /etc/mkinitcpio.conf,
  /etc/man_db.conf, /etc/mke2fs.conf, /etc/fuse.conf, /etc/asound.conf,
  /etc/mdadm.conf, /etc/pamac.conf, /etc/nfs.conf, /etc/nfsmount.conf,
  /etc/resolv.conf, /etc/gai.conf, /etc/pacman-mirrors.conf,
  /etc/rsyncd.conf))

  scala> fileGroups.get("confx")
  res125: Option[Array[String]] = None



#+END_SRC

Method: .head -> Get first element of Map 

#+BEGIN_SRC scala 
  scala> fileGroups.head

  res143: (String, Array[String]) = ("",Array(/etc/motd, /etc/gemrc,
  /etc/environment, /etc/gshadow, /etc/shadow-, /etc/fstab, /etc/rpc,
  /etc/passwd, /etc/gnome-vfs-mime-magic, /etc/passwd-, /etc/sudoers,
  /etc/anacrontab, /etc/os-release, /etc/adjtime, /etc/netconfig,
  /etc/inputrc, /etc/timezone, /etc/shadow, /etc/lsb-release,
  /etc/shells, /etc/papersize, /etc/drirc, /etc/hostname, /etc/exports,
  /etc/machine-id, /etc/group-, /etc/nanorc, /etc/hosts, /etc/group,
  /etc/mtab, /etc/securetty, /etc/services, /etc/protocols,
  /etc/gshadow-, /etc/localtime, /etc/issue, /etc/ethertypes,
  /etc/manjaro-release, /etc/yaourtrc, /etc/profile, /etc/printcap,
  /etc/crypttab))

#+END_SRC

Method: .last -> Get last element of Map 

#+BEGIN_SRC scala 
  scala> fileGroups.last

  res145: (String, Array[String]) = (defs,Array(/etc/login.defs))
#+END_SRC

Method: .key -> Get all keys 

#+BEGIN_SRC scala 
// Get all  file extensions 
scala> fileGroups.keys
res114: Iterable[String] = Set("", backup, bash_logout, local, pacnew, lock, conf, cache, key, shutdown, updated, cfg, deny, bashrc, types, rc, gen, defs)

// Print all file extensions 
scala> fileGroups.keys.foreach(println)

backup
bash_logout
local
pacnew
lock
conf
cache
key
shutdown
updated
cfg
deny
bashrc
types
rc
gen
defs

#+END_SRC

Method: .values -> Get all values. 

#+BEGIN_SRC scala 
  scala> fileGroups.values
  res126: Iterable[Array[String]] = MapLike(Array(/etc/motd, /etc/gemrc,
  /etc/environment, /etc/gshadow, /etc/shadow-, /etc/fstab, /etc/rpc,
  /etc/passwd, /etc/gnome-vfs-mime-magic, /etc/passwd-, /etc/sudoers,
  /etc/anacrontab, /etc/os-release, /etc/adjtime, /etc/netconfig,
  /etc/inputrc, /etc/timezone, /etc/shadow, /etc/lsb-release,
  /etc/shells, /etc/papersize, /etc/drirc, /etc/hostname, /etc/exports,
  /etc/machine-id, /etc/group-, /etc/nanorc, /etc/hosts, /etc/group,
  /etc/mtab, /etc/securetty, /etc/services, /etc/protocols,
  /etc/gshadow-, /etc/localtime, /etc/issue, /etc/ethertypes,
  /etc/manjaro-release, /etc/yaourtrc, /etc/profile, /etc/printcap,
  /etc/crypttab), Array(/etc/pacman-mirrors.conf.20170402.backup),
  Array(/etc/bash.bash_logout), Array(/etc/rc.local),
    Array(/etc/pacman-mirrors.co...  scala>

  scala> fileGroups.values.head
  res129: Array[String] = Array(/etc/motd, /etc/gemrc, /etc/environment,
  /etc/gshadow, /etc/shadow-, /etc/fstab, /etc/rpc, /etc/passwd,
  /etc/gnome-vfs-mime-magic, /etc/passwd-, /etc/sudoers,
  /etc/anacrontab, /etc/os-release, /etc/adjtime, /etc/netconfig,
  /etc/inputrc, /etc/timezone, /etc/shadow, /etc/lsb-release,
  /etc/shells, /etc/papersize, /etc/drirc, /etc/hostname, /etc/exports,
  /etc/machine-id, /etc/group-, /etc/nanorc, /etc/hosts, /etc/group,
  /etc/mtab, /etc/securetty, /etc/services, /etc/protocols,
  /etc/gshadow-, /etc/localtime, /etc/issue, /etc/ethertypes,
  /etc/manjaro-release, /etc/yaourtrc, /etc/profile, /etc/printcap,
    /etc/crypttab)


#+END_SRC

Method: .size -> Get the number of Map elements or the number of key,
value pairs. 

#+BEGIN_SRC scala>
scala> fileGroups.size
res148: Int = 18

scala> fileGroups size
res149: Int = 18

#+END_SRC

Method: .mapValues -> Apply a function to each map value. 

#+BEGIN_SRC scala 

  /// Get a Map with all extension and number of files with a given extension.
  scala> fileGroups.mapValues(x => x.length)

  res136: scala.collection.immutable.Map[String,Int] = Map("" -> 42,
  backup -> 1, bash_logout -> 1, local -> 1, pacnew -> 1, lock -> 1,
  conf -> 34, cache -> 1, key -> 1, shutdown -> 1, updated -> 1, cfg ->
  2, deny -> 1, bashrc -> 1, types -> 1, rc -> 2, gen -> 1, defs -> 1)

  scala> fileGroups.mapValues(_.length)
  res137: scala.collection.immutable.Map[String,Int] = Map("" -> 42,
  backup -> 1, bash_logout -> 1, local -> 1, pacnew -> 1, lock -> 1,
  conf -> 34, cache -> 1, key -> 1, shutdown -> 1, updated -> 1, cfg ->
    2, deny -> 1, bashrc -> 1, types -> 1, rc -> 2, gen -> 1, defs -> 1)

  scala> fileGroups.mapValues(_.length).foreach(println)
  (,42)
  (backup,1)
  (bash_logout,1)
  (local,1)
  (pacnew,1)
  (lock,1)
  (conf,34)
  (cache,1)
  (key,1)
  (shutdown,1)
  (updated,1)
  (cfg,2)
  (deny,1)
  (bashrc,1)
  (types,1)
  (rc,2)
  (gen,1)
  (defs,1)


#+END_SRC

Method: .map  -> Apply a function to each to each (key, value) pair. 

#+BEGIN_SRC scala 

  scala>  fileGroups.map {case (k, v) => (k, v.length)}

  // Get new Map with (extension, number of files with extension)
  // pairs.
  //
  res160: scala.collection.immutable.Map[String,Int] = Map("" -> 42,
  backup -> 1, bash_logout -> 1, local -> 1, pacnew -> 1, lock -> 1,
  conf -> 34, cache -> 1, key -> 1, shutdown -> 1, updated -> 1, cfg ->
  2, deny -> 1, bashrc -> 1, types -> 1, rc -> 2, gen -> 1, defs -> 1)



  scala>  fileGroups.map {case (k, v) => (k, v.max)}

  res161: scala.collection.immutable.Map[String,String] = Map("" ->
  /etc/yaourtrc, backup -> /etc/pacman-mirrors.conf.20170402.backup,
  bash_logout -> /etc/bash.bash_logout, local -> /etc/rc.local,
  pacnew -> /etc/pacman-mirrors.conf.pacnew, lock -> /etc/.pwd.lock,
  conf -> /etc/vconsole.conf, cache -> /etc/ld.so.cache, key ->
  /etc/trusted-key.key, shutdown -> /etc/rc.local.shutdown, updated ->
  /etc/.updated, cfg -> /etc/vdpau_wrapper.cfg, deny -> /etc/cron.deny,
  bashrc -> /etc/bash.bashrc, types -> /etc/mime.types, rc ->
  /etc/slsh.rc, gen -> /etc/locale.gen, defs -> /etc/login.defs)

#+END_SRC

Method: .foreach -> Apply a function that returns Unit (returns no value or void) to each element. 

#+BEGIN_SRC scala 
  fileGroups.foreach {case (k, v) => printf("Number of files with extenson\t'%s'\t\t=%d\n", k, v.length)}

  scala>  fileGroups.foreach {case (k, v) => println(k)}

  backup
  bash_logout
  local
  pacnew
  lock
  conf
  cache
  key
  shutdown
  updated
  cfg
  deny
  bashrc
  types
  rc
  gen
  defs

  scala>  fileGroups.foreach {case (k, v) => println(k, v.length)}
  (,42)
  (backup,1)
  (bash_logout,1)
  (local,1)
  (pacnew,1)
  (lock,1)
  (conf,34)
  (cache,1)
  (key,1)
  (shutdown,1)
  (updated,1)
  (cfg,2)
  (deny,1)
  (bashrc,1)
  (types,1)
  (rc,2)
  (gen,1)
  (defs,1)

  scala>  fileGroups.mapValues(_.length).foreach(println)
  (,42)
  (backup,1)
  (bash_logout,1)
  (local,1)
  (pacnew,1)
  (lock,1)
  (conf,34)
  (cache,1)
  (key,1)
  (shutdown,1)
  (updated,1)
  (cfg,2)
  (deny,1)
  (bashrc,1)
  (types,1)
  (rc,2)
  (gen,1)
  (defs,1)

  scala>  fileGroups.foreach {case (k, v) => printf("Number of files with extenson\t'%s'\t\t=%d\n", k, v.length)}
  Number of files with extenson   ''      =42
  Number of files with extenson   'backup'        =1
  Number of files with extenson   'bash_logout'       =1
  Number of files with extenson   'local'     =1
  Number of files with extenson   'pacnew'        =1
  Number of files with extenson   'lock'      =1
  Number of files with extenson   'conf'      =34
  Number of files with extenson   'cache'     =1
  Number of files with extenson   'key'       =1
  Number of files with extenson   'shutdown'      =1
  Number of files with extenson   'updated'       =1
  Number of files with extenson   'cfg'       =2
  Number of files with extenson   'deny'      =1
  Number of files with extenson   'bashrc'        =1
  Number of files with extenson   'types'     =1
  Number of files with extenson   'rc'        =2
  Number of files with extenson   'gen'       =1
  Number of files with extenson   'defs'      =1


#+END_SRC

Method: .isEmpty -> Test if Map is empty. 

#+BEGIN_SRC scala
scala> fileGroups.isEmpty
res151: Boolean = false

#+END_SRC


Method: .toList -> Convert a Map to a list of key and values. 

#+BEGIN_SRC scala 
  scala> val fileCounts = fileGroups.mapValues(_.length)

  fileCounts: scala.collection.immutable.Map[String,Int] = Map("" -> 42,
  backup -> 1, bash_logout -> 1, local -> 1, pacnew -> 1, lock -> 1,
  conf -> 34, cache -> 1, key -> 1, shutdown -> 1, updated -> 1, cfg ->
  2, deny -> 1, bashrc -> 1, types -> 1, rc -> 2, gen -> 1, defs -> 1)



  scala> fileGroups.toList

  scala> fileCounts.toList
  res140: List[(String, Int)] = List(("",42), (backup,1),
  (bash_logout,1), (local,1), (pacnew,1), (lock,1), (conf,34),
  (cache,1), (key,1), (shutdown,1), (updated,1), (cfg,2), (deny,1),
  (bashrc,1), (types,1), (rc,2), (gen,1), (defs,1))

#+END_SRC

Method: .toArray -> Convert a Map to an array of key and values.

#+BEGIN_SRC scala 
  scala> val fileCounts = fileGroups.mapValues(_.length)

  scala> fileCounts.toArray
  res141: Array[(String, Int)] = Array(("",42), (backup,1),
  (bash_logout,1), (local,1), (pacnew,1), (lock,1), (conf,34),
  (cache,1), (key,1), (shutdown,1), (updated,1), (cfg,2), (deny,1),
  (bashrc,1), (types,1), (rc,2), (gen,1), (defs,1))

#+END_SRC

*** Mutable Collections
**** Array 

 - [[https://www.tutorialspoint.com/scala/scala_arrays.htm][Scala Arrays]] methods signatures. 

#+BEGIN_SRC scala 
  scala> val arr = Array(1, 2, 3, 4, 5, 6)
  arr: Array[Int] = Array(1, 2, 3, 4, 5, 6)

  // Type tab after the dot to show the Array methods
  scala> arr.
  ++              filterNot            maxBy               span            
  ++:             find                 min                 splitAt         
  +:              flatMap              minBy               startsWith      
  /:              flatten              mkString            stringPrefix    
  :+              fold                 nonEmpty            sum             
  :\              foldLeft             orElse              tail            
  addString       foldRight            padTo               tails           
  aggregate       forall               par                 take            
  andThen         foreach              partition           takeRight       
  apply           genericBuilder       patch               takeWhile       
  applyOrElse     groupBy              permutations        to              
  array           grouped              prefixLength        toArray         
  canEqual        hasDefiniteSize      product             toBuffer        
  clone           head                 reduce              toIndexedSeq    
  collect         headOption           reduceLeft          toIterable      
  collectFirst    indexOf              reduceLeftOption    toIterator      
  combinations    indexOfSlice         reduceOption        toList          
  companion       indexWhere           reduceRight         toMap           
  compose         indices              reduceRightOption   toSeq           
  contains        init                 repr                toSet           
  containsSlice   inits                reverse             toStream        
  copyToArray     intersect            reverseIterator     toTraversable   
  copyToBuffer    isDefinedAt          reverseMap          toVector        
  corresponds     isEmpty              runWith             transform       
  count           isTraversableAgain   sameElements        transpose       
  deep            iterator             scan                union           
  diff            last                 scanLeft            unzip           
  distinct        lastIndexOf          scanRight           unzip3          
  drop            lastIndexOfSlice     segmentLength       update          
  dropRight       lastIndexWhere       seq                 updated         
  dropWhile       lastOption           size                view            
  elemManifest    length               slice               withFilter      
  elemTag         lengthCompare        sliding             zip             
  endsWith        lift                 sortBy              zipAll          
  exists          map                  sortWith            zipWithIndex    
  filter          max                  sorted                              


#+END_SRC

Get first and last elements.

#+BEGIN_SRC scala 
scala> val arr = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)
arr: Array[Double] = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)

scala> arr.head
res10: Double = 3.4

scala> arr.tail
res11: Array[Double] = Array(2.5, -4.5, 4.0, 5.0, -6.31)

#+END_SRC

Get array tail (remove first element)

#+BEGIN_SRC scala 
scala> val arr = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)
arr: Array[Double] = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)

scala> arr.tail
res25: Array[Double] = Array(2.5, -4.5, 4.0, 5.0, -6.31)

scala> arr
res26: Array[Double] = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)
#+END_SRC

Get nth-element.

#+BEGIN_SRC scala 
scala> val arr = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)
arr: Array[Double] = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)

scala> arr(0)
res12: Double = 3.4

scala> arr(1)
res13: Double = 2.5

scala> arr(4)
res14: Double = 5.0

scala> arr(10)
java.lang.ArrayIndexOutOfBoundsException: 10
  ... 32 elided

#+END_SRC

Change nth-element. 

#+BEGIN_SRC scala 
scala> val arr = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)
arr: Array[Double] = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)

scala> arr(3)
res0: Double = 4.0

scala> arr(3) = 100.0

scala> arr
res2: Array[Double] = Array(3.4, 2.5, -4.5, 100.0, 5.0, -6.31)

scala> arr(0)
res3: Double = 3.4

scala> arr(0) = 5.0

scala> arr
res5: Array[Double] = Array(5.0, 2.5, -4.5, 100.0, 5.0, -6.31)

scala> arr(0)
res6: Double = 5.0

#+END_SRC

Get minimum and maximum elements.

#+BEGIN_SRC scala 
scala> arr
res18: Array[Double] = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)

scala> arr.max
res19: Double = 5.0

scala> arr.min
res20: Double = -6.31
#+END_SRC

Get array length.

#+BEGIN_SRC scala
  scala> val arr = Array(1, 2, 3, 4, 5, 6)
  arr: Array[Int] = Array(1, 2, 3, 4, 5, 6)

  scala> arr.length
  length   lengthCompare

  scala> arr.length
  res6: Int = 6

#+END_SRC

Reverse array. 

#+BEGIN_SRC scala 
scala> val arr = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)
arr: Array[Double] = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)

scala> arr.reverse
res16: Array[Double] = Array(-6.31, 5.0, 4.0, -4.5, 2.5, 3.4)

scala> arr
res17: Array[Double] = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)
#+END_SRC

Convert Array to List.

#+BEGIN_SRC scala 
scala> val arr = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)
arr: Array[Double] = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)

scala> arr.toList
res21: List[Double] = List(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)

scala> arr
res22: Array[Double] = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)
#+END_SRC

Get array sum: 

#+BEGIN_SRC scala 
  scala> val arr = Array(1, 2, 3, 4, 5, 6)
  arr: Array[Int] = Array(1, 2, 3, 4, 5, 6)

  scala> arr.sum
  res7: Int = 21

#+END_SRC

Get array product: 

#+BEGIN_SRC scala 
  scala> val arr = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)
  arr: Array[Double] = Array(3.4, 2.5, -4.5, 4.0, 5.0, -6.31)

  scala> arr.product
  res9: Double = 4827.15

#+END_SRC

Map - Apply a function to all array elements.

#+BEGIN_SRC scala 
  scala> val arr = Array(3, 2, -4, 4, 5, -6)
  arr: Array[Int] = Array(3, 2, -4, 4, 5, -6)

  // Map with anonymous function
  //--------------------------------------------------
  scala> arr.map (x => x * 3)
  res30: Array[Int] = Array(9, 6, -12, 12, 15, -18)

  scala> arr map (x => x * 3)
  res35: Array[Int] = Array(9, 6, -12, 12, 15, -18)

  // Map a function 
  // 
  scala> def fn(x: Int) = x * 2 - 5
  fn: (x: Int)Int

  scala> arr.map(fn)
  res34: Array[Int] = Array(1, -1, -13, 3, 5, -17)

  scala> arr map fn
  res36: Array[Int] = Array(1, -1, -13, 3, 5, -17)


  // Convert integer to double 
  scala> 10
  res41: Int = 10

  scala> 10.toDouble
  res42: Double = 10.0

  // Map a function that applies a method.
  //--------------------------------------------------
  scala> arr map (_.toDouble)
  res43: Array[Double] = Array(3.0, 2.0, -4.0, 4.0, 5.0, -6.0)

  scala> arr map (_.toString)
  res54: Array[String] = Array(3, 2, -4, 4, 5, -6)

  scala> arr map (_.toHexString)
  res58: Array[String] = Array(3, 2, fffffffc, 4, 5, fffffffa)

  // Math syntax sugars 
  //-----------------------------------------------
  scala> arr map (_ + 10)
  res44: Array[Int] = Array(13, 12, 6, 14, 15, 4)

  scala> arr map (_ * 10)
  res45: Array[Int] = Array(30, 20, -40, 40, 50, -60)

  scala> arr map (_ * 10) map (5 + _)
  res49: Array[Int] = Array(35, 25, -35, 45, 55, -55)

  scala> arr map (_ * 10) sum
  res48: Int = 40

  scala> arr
  res51: Array[Int] = Array(3, 2, -4, 4, 5, -6)

  //  13 = 16 - 3
  //  14 = 16 - 2
  //  20 = 16 -(-4) 
  //  ... ... 
  scala> arr map (16 - _)
  res52: Array[Int] = Array(13, 14, 20, 12, 11, 22)


#+END_SRC

Filter - an array. Select all array elements that satisfies a
predicate. 

#+BEGIN_SRC scala 
  scala> val arr = Array(3, 2, -4, 4, 5, -6)
  arr: Array[Int] = Array(3, 2, -4, 4, 5, -6)

  scala> arr.filter(x => x > 0)
  res68: Array[Int] = Array(3, 2, 4, 5

  scala> arr filter (x => x > 0)
  res70: Array[Int] = Array(3, 2, 4, 5)

  scala> arr filter (x => x > 0) sum
  res71: Int = 14

  scala> arr filter (x => x > 0) product
  res72: Int = 120


  scala> arr.filter(_ > 0)
  res74: Array[Int] = Array(3, 2, 4, 5)

  scala> arr.filter(_ < 0)
  res77: Array[Int] = Array(-4, -6)

  scala> arr filter (_ < 0)
  res78: Array[Int] = Array(-4, -6)

    
#+END_SRC

Reduce (fold). It fails for empty arrays. 

 - acc stands for accumulator. 

#+BEGIN_SRC scala 
scala> val arr = Array(1, 2, 3, 4, 5, 6)
arr: Array[Int] = Array(1, 2, 3, 4, 5, 6)

// sum of array elements 
scala> arr.reduce((acc, x) => acc + x)
res12: Int = 21

scala> arr.sum
res15: Int = 21

// product of array elements 
scala> arr.reduce((acc, x) => acc * x)
res16: Int = 720

scala> arr.product
res17: Int = 720

scala> arr.reduce((acc, x) => 10 * acc + x)
res18: Int = 123456

scala> arr reduce((acc, x) => acc * x)
res21: Int = 720


scala> val emptyArr: Array[Double] = Array()
emptyArr: Array[Double] = Array()

scala> emptyArr.reduce((acc, x) => 10 * acc + x)
java.lang.UnsupportedOperationException: empty.reduceLeft
  at scala.collection.TraversableOnce$class.reduceLeft(TraversableOnce.scala:180)
  at scala.collection.mutable.ArrayOps$ofDouble.scala$collection$IndexedSeqOptimized$$super$reduceLeft(ArrayOps.scala:270)
  at scala.collection.IndexedSeqOptimized$class.reduceLeft(IndexedSeqOptimized.scala:74)
  at scala.collection.mutable.ArrayOps$ofDouble.reduceLeft(ArrayOps.scala:270)
  at scala.collection.TraversableOnce$class.reduce(TraversableOnce.scala:208)
  at scala.collection.mutable.ArrayOps$ofDouble.reduce(ArrayOps.scala:270)
  ... 32 elided


#+END_SRC


foldLeft - Like reduce, but it works for empty arrays. 

#+BEGIN_SRC scala 
scala> val arr = Array(1, 2, 3, 4, 5, 6)
arr: Array[Int] = Array(1, 2, 3, 4, 5, 6)

scala> val emptyArr : Array[Int] = Array()
emptyArr: Array[Int] = Array()

scala> arr.foldLeft(0)((acc, x) => 10 * acc + x)
res30: Int = 123456

scala> emptyArr.foldLeft(0)((acc, x) => 10 * acc + x)
res33: Int = 0


scala> arr.foldLeft(1)((acc, x) => acc * x)
res38: Int = 720

scala> emptyArr.foldLeft(1)((acc, x) => acc * x)
res39: Int = 1

scala> arr.foldLeft(())((_, x) => println(x))
1
2
3
4
5
6

// - '()' - Unit type 
//
scala> emptyArr.foldLeft(())((_, x) => println(x))

scala> ()

scala> 

#+END_SRC

foldRight 

#+BEGIN_SRC scala 
scala> val arr = Array(1, 2, 3, 4, 5, 6)
arr: Array[Int] = Array(1, 2, 3, 4, 5, 6)

scala> val emptyArr : Array[Int] = Array()
emptyArr: Array[Int] = Array()

scala> arr.foldRight(0)((x, acc) => 10* acc + x)
res46: Int = 654321

scala> emptyArr.foldRight(0)((x, acc) => 10* acc + x)
res47: Int = 0


scala> arr.foldRight(0)((x, acc) => acc + x)
res49: Int = 21

scala> arr.foldRight(1)((x, acc) => acc * x)
res50: Int = 720

#+END_SRC

Group By 

 - groupBy[k](f: Element => key) : Map[key, Array[Element]]

#+BEGIN_SRC scala 


  def getFileExtension(file: String) = {
    val i = file.lastIndexOf('.')
    if ( i > 0)
      file.substring(i+1)
    else
      ""
  }


  val flist = List(
    "/downloads/magazine.pdf"
   ,"afile.html"
   ,"file2.html"
   ,"file3.png"
   ,"config"
   ,"imageFun.png"
   ,"unix.pdf"
   ,"script10.scala"
   ,"bashrc"
    )


  scala> val flist = List(
       |   "/downloads/magazine.pdf"
       |  ,"afile.html"
       |  ,"file2.html"
       |  ,"file3.png"
       |  ,"config"
       |  ,"imageFun.png"
       |  ,"unix.pdf"
       |  ,"script10.scala"
       |  ,"bashrc"
       |   )
  flist: List[String] = List(/downloads/magazine.pdf, afile.html, file2.html, file3.png, config, imageFun.png, unix.pdf, script10.scala, bashrc)


  scala> flist map getFileExtension
  res63: List[String] = List(pdf, html, html, png, "", png, pdf, scala, "")


  scala> val fgroups = flist.groupBy(getFileExtension) fgroups:
  scala.collection.immutable.Map[String,List[String]] = Map("" ->
  List(config, bashrc), png -> List(file3.png, imageFun.png), pdf ->
  List(/downloads/magazine.pdf, unix.pdf), scala ->
  List(script10.scala), html -> List(afile.html, file2.html))

  // Get extensions
  //
  scala> fgroups.keys
  res74: Iterable[String] = Set("", png, pdf, scala, html)

  scala> fgroups.keys.foreach(println)

  png
  pdf
  scala
  html

  // Get all files without extension
  //
  scala> fgroups.get("")
  res75: Option[List[String]] = Some(List(config, bashrc))

  scala> fgroups.get("").get
  res79: List[String] = List(config, bashrc)

  scala> fgroups.get("tgz")
  res81: Option[List[String]] = None

  scala> fgroups.get("tgz").get
  java.util.NoSuchElementException: None.get
    at scala.None$.get(Option.scala:347)
    at scala.None$.get(Option.scala:345)
    ... 32 elided


  // Get all files with extension *.png
  scala> fgroups.get("png")
  res76: Option[List[String]] = Some(List(file3.png, imageFun.png))


  scala> var files = (new java.io.File("/etc/")).listFiles().filter(_.isFile)
  files: Array[java.io.File] = Array(/etc/motd, /etc/gemrc,
  /etc/ld.so.cache, /etc/environment, /etc/sensors3.conf, /etc/gshadow,
  /etc/cron.deny, /etc/shadow-, /etc/vdpau_wrapper.cfg,
  /etc/pacman.conf, /etc/cpufreq-bench.conf, /etc/makepkg.conf,
  /etc/ld.so.conf, /etc/fstab, /etc/host.conf, /etc/rpc,
  /etc/mime.types, /etc/locale.gen, /etc/passwd, /etc/healthd.conf,
  /etc/gnome-vfs-mime-magic, /etc/ts.conf, /etc/resolvconf.conf,
  /etc/passwd-, /etc/logrotate.conf, /etc/locale.conf,
  /etc/pacman-mirrors.conf.20170402.backup, /etc/login.defs,
  /etc/sudoers, /etc/request-key.conf, /etc/bash.bashrc,
  /etc/anacrontab, /etc/nscd.conf, /etc/os-release, /etc/adjtime,
  /etc/dnsmasq.conf, /etc/netconfig, /etc/mail.rc, /etc/inputrc,
  /etc/nsswitch.conf, /etc/ntp.conf, /etc/updatedb.conf,
  /etc/dhcpcd.conf, /e...  scala>


  scala> val fileGroups = files.map(_.getPath).groupBy(getFileExtension)
  fileGroups: scala.collection.immutable.Map[String,Array[String]] =
  Map("" -> Array(/etc/motd, /etc/gemrc, /etc/environment, /etc/gshadow,
  /etc/shadow-, /etc/fstab, /etc/rpc, /etc/passwd,
  /etc/gnome-vfs-mime-magic, /etc/passwd-, /etc/sudoers,
  /etc/anacrontab, /etc/os-release, /etc/adjtime, /etc/netconfig,
  /etc/inputrc, /etc/timezone, /etc/shadow, /etc/lsb-release,
  /etc/shells, /etc/papersize, /etc/drirc, /etc/hostname, /etc/exports,
  /etc/machine-id, /etc/group-, /etc/nanorc, /etc/hosts, /etc/group,
  /etc/mtab, /etc/securetty, /etc/services, /etc/protocols,
  /etc/gshadow-, /etc/localtime, /etc/issue, /etc/ethertypes,
  /etc/manjaro-release, /etc/yaourtrc, /etc/profile, /etc/printcap,
  /etc/crypttab), backup ->
  Array(/etc/pacman-mirrors.conf.20170402.backup), bash_logout ->
  Array(/etc/bash.bash...  scala>


  scala> val fileGroups = files map(_.getPath) groupBy getFileExtension
  fileGroups: scala.collection.immutable.Map[String,Array[String]] =
  Map("" -> Array(/etc/motd, /etc/gemrc, /etc/environment, /etc/gshadow,
  /etc/shadow-, /etc/fstab, /etc/rpc, /etc/passwd,
  /etc/gnome-vfs-mime-magic, /etc/passwd-, /etc/sudoers,
  /etc/anacrontab, /etc/os-release, /etc/adjtime, /etc/netconfig,
  /etc/inputrc, /etc/timezone, /etc/shadow, /etc/lsb-release,
  /etc/shells, /etc/papersize, /etc/drirc, /etc/hostname, /etc/exports,
  /etc/machine-id, /etc/group-, /etc/nanorc, /etc/hosts, /etc/group,
  /etc/mtab, /etc/securetty, /etc/services, /etc/protocols,
  /etc/gshadow-, /etc/localtime, /etc/issue, /etc/ethertypes,
  /etc/manjaro-release, /etc/yaourtrc, /etc/profile, /etc/printcap,
  /etc/crypttab), backup ->
  Array(/etc/pacman-mirrors.conf.20170402.backup), bash_logout ->
  Array(/etc/bash.bash...  scala>

  /// Show all file extensions 
  scala> fileGroups.keys.foreach(println)

  backup
  bash_logout
  local
  pacnew
  lock
  conf
  cache
  key
  shutdown
  updated
  cfg
  deny
  bashrc
  types
  rc
  gen
  defs

  scala> fileGroups.get("conf")
  res90: Option[Array[String]] = Some([Ljava.lang.String;@610b9cb3)

  scala> fileGroups.get("conf").get res91: Array[String] =
  Array(/etc/sensors3.conf, /etc/pacman.conf, /etc/cpufreq-bench.conf,
  /etc/makepkg.conf, /etc/ld.so.conf, /etc/host.conf, /etc/healthd.conf,
  /etc/ts.conf, /etc/resolvconf.conf, /etc/logrotate.conf,
  /etc/locale.conf, /etc/request-key.conf, /etc/nscd.conf,
  /etc/dnsmasq.conf, /etc/nsswitch.conf, /etc/ntp.conf,
  /etc/updatedb.conf, /etc/dhcpcd.conf, /etc/krb5.conf,
  /etc/openswap.conf, /etc/vconsole.conf, /etc/mkinitcpio.conf,
  /etc/man_db.conf, /etc/mke2fs.conf, /etc/fuse.conf, /etc/asound.conf,
  /etc/mdadm.conf, /etc/pamac.conf, /etc/nfs.conf, /etc/nfsmount.conf,
  /etc/resolv.conf, /etc/gai.conf, /etc/pacman-mirrors.conf,
  /etc/rsyncd.conf)

  scala> fileGroups.get("conf").get.take(10).foreach(println)
  /etc/sensors3.conf
  /etc/pacman.conf
  /etc/cpufreq-bench.conf
  /etc/makepkg.conf
  /etc/ld.so.conf
  /etc/host.conf
  /etc/healthd.conf
  /etc/ts.conf
  /etc/resolvconf.conf
  /etc/logrotate.conf

  scala> fileGroups.get("cfg").get.take(10).foreach(println)
  /etc/vdpau_wrapper.cfg
  /etc/rc_maps.cfg

  /// Show all files without extension 
  scala> fileGroups.get("").get.take(10).foreach(println)
  /etc/motd
  /etc/gemrc
  /etc/environment
  /etc/gshadow
  /etc/shadow-
  /etc/fstab
  /etc/rpc
  /etc/passwd
  /etc/gnome-vfs-mime-magic
  /etc/passwd-

  // Get the number of files of each extension 
  cala> val fileCounts = fileGroups.mapValues(n => n.length)
  fileCounts: scala.collection.immutable.Map[String,Int] = Map("" -> 42,
  backup -> 1, bash_logout -> 1, local -> 1, pacnew -> 1, lock -> 1,
  conf -> 34, cache -> 1, key -> 1, shutdown -> 1, updated -> 1, cfg ->
  2, deny -> 1, bashrc -> 1, types -> 1, rc -> 2, gen -> 1, defs -> 1)

  // Count the number of *.cfg 
  scala> fileCounts.get("cfg").get
  res102: Int = 2

  // Count the number of files without extension
  scala> fileCounts.get("")
  res99: Option[Int] = Some(42)

  scala> fileCounts.get("conf")
  res100: Option[Int] = Some(34)

  scala> fileCounts.get("conf").get
  res101: Int = 34

  // Show how many files are of each extension.
  //
  // - 2 files with *.cfg extension and 42 without extension.
  //   
  scala> fileCounts.foreach(println)
  (,42)
  (backup,1)
  (bash_logout,1)
  (local,1)
  (pacnew,1)
  (lock,1)
  (conf,34)
  (cache,1)
  (key,1)
  (shutdown,1)
  (updated,1)
  (cfg,2)
  (deny,1)
  (bashrc,1)
  (types,1)
  (rc,2)
  (gen,1)
  (defs,1)

#+END_SRC

Foreach - Apply a function that performs side-effect to each element. 

#+BEGIN_SRC scala 
  scala> val arr = Array(3, 2, -4, 4, 5, -6)
  arr: Array[Int] = Array(3, 2, -4, 4, 5, -6)

  scala> arr.foreach(println)
  3
  2
  -4
  4
  5
  -6

  scala> arr foreach println
  3
  2
  -4
  4
  5
  -6

  scala> arr.foreach(x => println("x = " + x))
  x = 3
  x = 2
  x = -4
  x = 4
  x = 5
  x = -6

  scala> arr foreach (x => println("x = " + x))
  x = 3
  x = 2
  x = -4
  x = 4
  x = 5
  x = -6


  // More practical example:
  //

  scala> var files = (new java.io.File("/etc/")).listFiles()

  files: Array[java.io.File] = Array(/etc/systemd, /etc/motd,
  /etc/gemrc, /etc/adobe, /etc/ld.so.cache, /etc/environment,
  /etc/libreoffice, /etc/rc_keymaps, /etc/sensors3.conf, /etc/gshadow,
  /etc/acpi, /etc/pkcs11, /etc/modules-load.d, ... )

  // Get the number of files
  //--------------------------------
  scala> files.length
  res80: Int = 188

  scala> files.size
  res81: Int = 188

  scala> files.head
  res82: java.io.File = /etc/systemd

  scala> files.last
  res83: java.io.File = /etc/rsyncd.conf

  scala> val f = files.head
  f: java.io.File = /etc/systemd

  scala> f. // Type tab to show class tabs 
  canExecute      getAbsoluteFile    getTotalSpace    list              setWritable   
  canRead         getAbsolutePath    getUsableSpace   listFiles         toPath        
  canWrite        getCanonicalFile   hashCode         mkdir             toString      
  compareTo       getCanonicalPath   isAbsolute       mkdirs            toURI         
  createNewFile   getFreeSpace       isDirectory      renameTo          toURL         
  delete          getName            isFile           setExecutable                   
  deleteOnExit    getParent          isHidden         setLastModified                 
  equals          getParentFile      lastModified     setReadOnly                     
  exists          getPath            length           setReadable

  scala> files.head.getName
  res84: String = systemd

  scala> files.head.getPath
  res86: String = /etc/systemd

  scala> files.head.toURL
  res87: java.net.URL = file:/etc/systemd/

  scala> files.head.toURI
  res88: java.net.URI = file:/etc/systemd/
    
  scala> files.head.isFile
  res89: Boolean = false

  scala> files.head.isDirectory
  res90: Boolean = true

  // Filter all file objects that are directory and take 10 directories.
  scala> files.filter(_.isDirectory).take(10)
  res94: Array[java.io.File] = Array(/etc/systemd, /etc/adobe, /etc/libreoffice, /etc/rc_keymaps, /etc/acpi, /etc/pkcs11, /etc/modules-load.d, /etc/gufw, /etc/security, /etc/tmpfiles.d)
    

  // Get directories and print 15.
  //
  scala> files.filter(_.isDirectory).take(15).foreach(println)
  /etc/systemd
  /etc/adobe
  /etc/libreoffice
  /etc/rc_keymaps
  /etc/acpi
  /etc/pkcs11
  /etc/modules-load.d
  /etc/gufw
  /etc/security
  /etc/tmpfiles.d
  /etc/ppp
  /etc/iptables
  /etc/pulse
  /etc/xinetd.d
  /etc/ca-certificates

  // Filter 5 files   
  scala> files.filter(_.isFile).take(5)
  res96: Array[java.io.File] = Array(/etc/motd, /etc/gemrc, /etc/ld.so.cache, /etc/environment, /etc/sensors3.conf)

  scala> files.filter(_.isFile).take(15).foreach(println)
  /etc/motd
  /etc/gemrc
  /etc/ld.so.cache
  /etc/environment
  /etc/sensors3.conf
  /etc/gshadow
  /etc/cron.deny
  /etc/shadow-
  /etc/vdpau_wrapper.cfg
  /etc/pacman.conf
  /etc/cpufreq-bench.conf
  /etc/makepkg.conf
  /etc/ld.so.conf
  /etc/fstab
  /etc/host.conf

  scala> :paste
  // Entering paste mode (ctrl-D to finish)

  files
    .filter(_.isFile)
    .take(15)
    .foreach(println)

  // Exiting paste mode, now interpreting.

  /etc/motd
  /etc/gemrc
  /etc/ld.so.cache
  /etc/environment
  /etc/sensors3.conf
  /etc/gshadow
  /etc/cron.deny
  /etc/shadow-
  /etc/vdpau_wrapper.cfg
  /etc/pacman.conf
  /etc/cpufreq-bench.conf
  /etc/makepkg.conf
  /etc/ld.so.conf
  /etc/fstab
  /etc/host.conf

    
  scala> files filter (_.isFile) take 15 foreach println
  /etc/motd
  /etc/gemrc
  /etc/ld.so.cache
  /etc/environment
  /etc/sensors3.conf
  /etc/gshadow
  /etc/cron.deny
  /etc/shadow-
  /etc/vdpau_wrapper.cfg
  /etc/pacman.conf
  /etc/cpufreq-bench.conf
  /etc/makepkg.conf
  /etc/ld.so.conf
  /etc/fstab
  /etc/host.conf
#+END_SRC

**** Mutable List

#+BEGIN_SRC scala
scala> import collection.mutable.ListBuffer
import collection.mutable.ListBuffer

scala> val xs = ListBuffer[Double]()
xs: scala.collection.mutable.ListBuffer[Double] = ListBuffer()

scala> (1 to 10).foreach(i => xs.append(i.toDouble * 2.5 - 4.0))

scala> xs
res42: scala.collection.mutable.ListBuffer[Double] = ListBuffer(-1.5, 1.0, 3.5, 6.0, 8.5, 11.0, 13.5, 16.0, 18.5, 21.0)

scala>
#+END_SRC

**** Mutable Maps                                       :collection:map:hash:

#+BEGIN_SRC scala

scala> import scala.collection.mutable.Map
import scala.collection.mutable.Map

scala> val hmap1 = Map[Int, String]()
hmap1: scala.collection.mutable.Map[Int,String] = Map()

scala> hmap1 += (1 -> "Netherlands")
res49: hmap1.type = Map(1 -> Netherlands)

scala> hmap1 += (2 -> "Mexico")
res50: hmap1.type = Map(2 -> Mexico, 1 -> Netherlands)

scala> hmap1 += (3 -> "Italy")
res51: hmap1.type = Map(2 -> Mexico, 1 -> Netherlands, 3 -> Italy)

scala> hmap1 += (10 -> "Japan")

res52: hmap1.type = Map(2 -> Mexico, 10 -> Japan, 1 -> Netherlands, 3 -> Italy)

scala>
scala> hmap1
res53: scala.collection.mutable.Map[Int,String] = Map(2 -> Mexico, 10 -> Japan, 1 -> Netherlands, 3 -> Italy)

scala> hmap1(3)
res54: String = Italy

scala> hmap1(10)
res55: String = Japan

scala> hmap1(100)
java.util.NoSuchElementException: key not found: 100
  at scala.collection.MapLike$class.default(MapLike.scala:228)
  at scala.collection.AbstractMap.default(Map.scala:59)
  at scala.collection.mutable.HashMap.apply(HashMap.scala:65)
  ... 32 elided

scala>
#+END_SRC

** Case classes and pattern matching 

Scala case classes are similar to Haskell algebraic data types and
supports pattern matching. It is useful to represent abstract syntax
trees and build interpreters and pasers.

*Example 1:* 

 - Sealed class means that it is not possible to define any other
   sublclass of class Shape. 

#+BEGIN_SRC scala 
  sealed abstract class Shape
  case class Square   (side: Double)                    extends Shape
  case class Rectangle(height: Double, width: Double)   extends Shape
  case class Circle   (radius: Double)                  extends Shape
  case class Triangle (a: Double, b: Double, c: Double) extends Shape


  def computeArea(shape: Shape) = shape match {
    case Square(x)       => x * x
    case Rectangle(w, h) => w * h
    case Circle(r)       => Math.PI * r * r
    case _               => error("Error: Not implemented. See Heron's formula.")
  }


  def computePerimiter(shape: Shape) = shape match {
    case Square(x)         => 4 * x
    case Rectangle(w, h)   => 2 * (w + h)
    case Circle(r)         => 2 * Math.PI * r 
    case Triangle(a, b, c) => a + b + c 
  }

  def classify(shape: Shape) = shape match {
    case Square(_)       => "square"
    case Rectangle(_,_)  => "rectangle"
    case Circle(_)       => "circle"
    case Triangle(_,_,_) => "triangle"
  }


  scala> val s = Square(10.0)
  s: Square = Square(10.0)

  scala> val r = Rectangle(5.0, 10.0)
  r: Rectangle = Rectangle(5.0,10.0)

  scala> val c = Circle(3.0)
  c: Circle = Circle(3.0)

  scala> val t = Triangle(2.0, 4.0, 5.0)
  t: Triangle = Triangle(2.0,4.0,5.0)

  scala> 


  scala> computeArea(s)
  res27: Double = 100.0

  scala> computeArea(r)
  res28: Double = 50.0

  scala> computeArea(t)
  java.lang.RuntimeException: Error: Not implemented. See heron formula.
    at scala.sys.package$.error(package.scala:27)
    at scala.Predef$.error(Predef.scala:144)
    at .computeArea(<console>:25)
    ... 32 elided

  scala> 


  scala> List(s, r, t)
  res30: List[Product with Serializable with Shape] = List(Square(10.0), Rectangle(5.0,10.0), Triangle(2.0,4.0,5.0))

  scala> List(s, r, t).foreach(println)
  Square(10.0)
  Rectangle(5.0,10.0)
  Triangle(2.0,4.0,5.0)

  scala> List(s, r, t).map(classify)
  res32: List[String] = List(square, rectangle, triangle)

  scala> List(s, r, t).map(computePerimiter)
  res33: List[Double] = List(40.0, 30.0, 11.0)


#+END_SRC

*Example 2: Abstract syntax tree.*

#+BEGIN_SRC scala 
  sealed abstract class Expr
  case class Val(x: Int)           extends Expr
  case class Add(r: Expr, s: Expr) extends Expr
  case class Sub(r: Expr, s: Expr) extends Expr
  case class Mul(r: Expr, s: Expr) extends Expr


  // It is possible to define multiple interpreters for this AST.

  // This interpreter evaluates the AST 
  def evalExpr(expr: Expr): Int = expr match {
    case Val(n)    => n
    case Add(r, s) => computeExpr(r) + computeExpr(s)
    case Sub(r, s) => computeExpr(r) - computeExpr(s)
    case Mul(r, s) => computeExpr(r) * computeExpr(s)
  }


  // This interpreter show the expresion 
  def showExpr(expr: Expr): String = expr match {
    case Val(n)    => n.toString

    case Add(Val(x), Val(y)) => x + " + " + y
    case Sub(Val(x), Val(y)) => x + " - " + y
    case Mul(Val(x), Val(y)) => x + " * " + y    

    case Add(Val(x), s) => x + " + (" + showExpr(s) + ")"
    case Sub(Val(x), s) => x + " - (" + showExpr(s) + ")"
    case Mul(Val(x), s) => x + " * (" + showExpr(s) + ")"    

    case Add(r, Val(y)) => "(" + showExpr(r) + ") + " + y
    case Sub(r, Val(y)) => "(" + showExpr(r) + ") - " + y
    case Mul(r, Val(y)) => "(" + showExpr(r) + ") * " + y    

    case Add(r, s) => "(" + showExpr(r) + ") + (" + showExpr(s) + ")"
    case Sub(r, s) => "(" + showExpr(r) + ") - (" + showExpr(s) + ")"
    case Mul(r, s) => "(" + showExpr(r) + ") * (" + showExpr(s) + ")"
  }

  // This interpreter shows the expresion and its value 
  def showEval(expr: Expr) = {
    println(showExpr(expr) + " = " + evalExpr(expr))
  }



  scala> val e1 = Val(10)
  e1: Val = Val(10)

  scala> val e2 = Add(Val(10), Val(5))
  e2: Add = Add(Val(10),Val(5))

  scala> val e3 = Mul(Val(3), e2)
  e3: Mul = Mul(Val(3),Add(Val(10),Val(5)))

  scala> val e4 = Sub(e3, e1)
  e4: Sub = Sub(Mul(Val(3),Add(Val(10),Val(5))),Val(10))


  scala> evalExpr(e1)
  res56: Int = 10

  scala> evalExpr(e2)
  res57: Int = 15

  scala> evalExpr(e3)
  res58: Int = 45

  scala> evalExpr(e4)
  res59: Int = 35


  scala> showExpr(e1)
  res60: String = 10

  scala> showExpr(e2)
  res61: String = 10 + 5

  scala> showExpr(e3)
  res62: String = 3 * (10 + 5)

  scala> showExpr(e4)
  res63: String = (3 * (10 + 5)) - 10

  scala> List(e1, e2, e3, e4).foreach(println)
  Val(10)
  Add(Val(10),Val(5))
  Mul(Val(3),Add(Val(10),Val(5)))
  Sub(Mul(Val(3),Add(Val(10),Val(5))),Val(10))


  scala> List(e1, e2, e3, e4).foreach(showEval)
  10 = 10
  10 + 5 = 15
  3 * (10 + 5) = 45
  (3 * (10 + 5)) - 10 = 35

#+END_SRC

** Pattern Matching 

Example 1 - Show month name. 

#+BEGIN_SRC scala 

  def getMonthName(month: Int) = month match {
    case 1  => "January"
    case 2  => "February"
    case 3  => "March"
    case 4  => "April"
    case 5  => "May"
    case 6  => "June"
    case 7  => "July"
    case 8  => "August"
    case 9  => "September"
    case 10 => "October"
    case 11 => "November"
    case 12 => "December"
    case _  => error("Error: Invalid month")
  }


  scala> getMonthName(1)
  res75: String = January

  scala> getMonthName(9)
  res76: String = September

  scala> getMonthName(0)
  java.lang.RuntimeException: Error: Invalid month
    at scala.sys.package$.error(package.scala:27)
    at scala.Predef$.error(Predef.scala:144)
    at .getMonthName(<console>:26)
    ... 32 elided


  def getMonthName2(month: Int) = month match {
    case 1  => Some("January")
    case 2  => Some("February")
    case 3  => Some("March")
    case 4  => Some("April")
    case 5  => Some("May")
    case 6  => Some("June")
    case 7  => Some("July")
    case 8  => Some("August")
    case 9  => Some("September")
    case 10 => Some("October")
    case 11 => Some("November")
    case 12 => Some("December")
    case _  => None 
  }


  scala> getMonthName2(1)
  res78: Option[String] = Some(January)

  scala> getMonthName2(12)
  res79: Option[String] = Some(December)

  scala> getMonthName2(0)
  res80: Option[String] = None

  scala> getMonthName2(-10)
  res81: Option[String] = None
#+END_SRC

Example 2 - Pattern matching with strings. 

#+BEGIN_SRC scala 

  def showCurrencyName(cur: String) = cur match {
    case "USD" => "United States Dollar"
    case "CAD" => "Canadian Dollar"
    case "EUR" => "Euro"
    case "AUD" => "Australian Dollar"
    case "GBP" => "Great Britain Pound"
    case "JPY" => "Japanese Yen"
    case "CNY" => "Chinese Yuan / Reminbi"
    case "HKD" => "Hong Kong Dollar"
    case "BRL" => "Brazilian Real"
    case "MXN" => "Mexican Peso"
    case "CHF" => "Switzerland Franc"
    case "XBT" => "Bitcoin"
    case _     => error("Error: I don't the name of this currency. Please teach me it.")
  }


  scala> showCurrencyName("CNY")
  res102: String = Chinese Yuan / Reminbi

  scala> showCurrencyName("JPY")
  res103: String = Japanese Yen

  scala> showCurrencyName("HKD")
  res104: String = Hong Kong Dollar

  scala> showCurrencyName("JPYx")
  java.lang.RuntimeException: Error: I don't the name of this currency. Please teach me it.
    at scala.sys.package$.error(package.scala:27)
    at scala.Predef$.error(Predef.scala:144)
    at .showCurrencyName(<console>:26)
    ... 32 elided


  scala> List("CNY", "HKD", "AUD", "BRL").map(showCurrencyName).foreach(println)
  Chinese Yuan / Reminbi
  Hong Kong Dollar
  Australian Dollar
  Brazilian Real

  scala> showCurrencyName("XBT")
  res109: String = Bitcoin
#+END_SRC

Example 3 - Pattern with number and case-classes. 

#+BEGIN_SRC scala 
  abstract sealed class Month
  case object Jan extends Month
  case object Feb extends Month
  case object Mar extends Month
  case object Apr extends Month
  case object May extends Month
  case object Jun extends Month
  case object Jul extends Month
  case object Aug extends Month
  case object Sep extends Month
  case object Oct extends Month
  case object Nov extends Month
  case object Dec extends Month

  def getMonthName(month: Month) = month match {
    case Jan => "January"
    case Feb => "February"
    case Mar => "March"
    case Apr => "April"
    case May => "May"
    case Jun => "June"
    case Jul => "July"
    case Aug => "August"
    case Sep => "September"
    case Oct => "October"
    case Nov => "November"
    case Dec => "December"
  }


  def numberToMonth(n: Int) = n match {
    case 1  => Jan
    case 2  => Feb
    case 3  => Mar
    case 4  => Apr
    case 5  => May
    case 6  => Jun
    case 7  => Jul
    case 8  => Aug
    case 9  => Sep
    case 10 => Oct
    case 11 => Nov
    case 12 => Dec
    case _  => error("Error: Invalid month number.")
  }


  def numberToMonth2(n: Int) = n match {
    case 1  => Some(Jan)
    case 2  => Some(Feb)
    case 3  => Some(Mar)
    case 4  => Some(Apr)
    case 5  => Some(May)
    case 6  => Some(Jun)
    case 7  => Some(Jul)
    case 8  => Some(Aug)
    case 9  => Some(Sep)
    case 10 => Some(Oct)
    case 11 => Some(Nov)
    case 12 => Some(Dec)
    case _  => None
  }


  scala> getMonthName(Jan)
  res85: String = January

  scala> getMonthName(Feb)
  res86: String = February

  scala> getMonthName(Aug)
  res87: String = August

  scala> getMonthName(Dec)
  res88: String = December


  scala> numberToMonth(1)
  res93: Product with Serializable with Month = Jan

  scala> numberToMonth(9)
  res94: Product with Serializable with Month = Sep

  scala> numberToMonth(-1)
  java.lang.RuntimeException: Error: Invalid month number.
    at scala.sys.package$.error(package.scala:27)
    at scala.Predef$.error(Predef.scala:144)
    at .numberToMonth(<console>:39)
    ... 32 elided


  scala> numberToMonth2(1)
  res97: Option[Product with Serializable with Month] = Some(Jan)

  scala> numberToMonth2(2)
  res98: Option[Product with Serializable with Month] = Some(Feb)

  scala> numberToMonth2(12)
  res99: Option[Product with Serializable with Month] = Some(Dec)

  scala> numberToMonth2(-1)
  res100: Option[Product with Serializable with Month] = None

  scala> numberToMonth2(0)
  res101: Option[Product with Serializable with Month] = None
#+END_SRC

Example 4 - Pattern matching with conditional. 

#+BEGIN_SRC scala 

  def classifyNumber(n: Int) = n match {
    case x if x < 0               => println("Negative number")
    case 0                        => println("zero")
    case x if x > 0 && x % 2 == 0 => println("Positive even number")
    case _                        => println("Positive odd number")
  }

  scala> classifyNumber(-2)
  Negative number

  scala> classifyNumber(-10)
  Negative number

  scala> classifyNumber(0)
  zero

  scala> classifyNumber(2)
  Positive even number

  scala> classifyNumber(21)
  Positive odd number

  scala> classifyNumber(210)
  Positive even number

  scala> classifyNumber(1213)
  Positive odd number


#+END_SRC

Example 5 - Recursive functions. 

#+BEGIN_SRC scala 

  def factorial(n: Int): Int = n match {
    case a if a < 0 => error("Error: Invalid input.")
    case 0 | 1      => 1
    case k          => k * factorial(k - 1)
  }


  scala> factorial(4)
  res126: Int = 24

  scala> factorial(5)
  res127: Int = 120

  scala> factorial(-5)
  java.lang.RuntimeException: Error: Invalid input.
    at scala.sys.package$.error(package.scala:27)
    at scala.Predef$.error(Predef.scala:144)
    at .factorial(<console>:14)
    ... 32 elided

  scala> factorial(0)
  res129: Int = 1

  scala> factorial(1)
  res130: Int = 1
#+END_SRC

Example 6 - Recursive list functions. 

#+BEGIN_SRC scala 
  scala> 1::List()
  res118: List[Int] = List(1)

  scala> 2::1::List()
  res119: List[Int] = List(2, 1)

  scala> 4::2::1::List()
  res120: List[Int] = List(4, 2, 1)


  def sumList(list: List[Int]): Int = list match {
    case List() => 0
    case hd::tl => hd + sumList(tl)
  }

  scala> sumList(List(1, 2, 3, 4, 5))
  res121: Int = 15

  scala> 

  def foreach[A](fn: A => Unit)(list: List[A]): Unit = list match {
    case List() => ()  // Do nothing.
    case hd::tl => fn(hd) ; foreach(fn)(tl)
  }

  scala> def foreach[A](fn: A => Unit)(list: List[A]): Unit = list match {
       |   case List() => ()  // Do nothing.
       |   case hd::tl => fn(hd) ; foreach(fn)(tl)
       | }
  foreach: [A](fn: A => Unit)(list: List[A])Unit

  scala> foreach(println)(List(1, 2, 3, 4))
  1
  2
  3
  4


  scala> val printAll = foreach(println)(_)
  printAll: List[Any] => Unit = <function1>



  scala> printAll(List("Hello", "World", "Scala"))
  Hello
  World
  Scala

  scala> printAll(List(1, 2, 3, 4, 5))
  1
  2
  3
  4
  5


#+END_SRC

* OOP - Object Orientated Programming 
** Singleton Object 

A singleton object is an object without class with a single
instance. It can be used as an ML-module. 

#+BEGIN_SRC scala 
  cala> :paste
  // Entering paste mode (ctrl-D to finish)


  object Module {

    val code = "xyzfmnk"

    var amount = 1000 

    def sayHello () = println("Hello world")

    def fn(x: Int, y: Int) = 3 * x + 4 * y

    def showFiles(path: String) = {
      val files = (new java.io.File(path)).listFiles().filter(_.isFile)
      files.foreach(println)    
    }

    def showDirectories(path: String) = {
      val files = (new java.io.File(path)).listFiles().filter(_.isDirectory)
      files.foreach(println)    
    }


  }


  scala> Module.fn _
  res204: (Int, Int) => Int = <function2>

  scala> Module.sayHello _
  res205: () => Unit = <function0>

  scala> Module.showFiles _
  res206: String => Unit = <function1>

  scala> Module.showFiles("/boot")
  /boot/initramfs-3.10-x86_64.img
  /boot/vmlinuz-4.9-x86_64
  /boot/initramfs-3.10-x86_64-fallback.img
  /boot/vmlinuz-3.10-x86_64
  /boot/initramfs-4.9-x86_64-fallback.img
  /boot/initramfs-4.9-x86_64.img
  /boot/intel-ucode.img
  /boot/linux310-x86_64.kver
  /boot/linux49-x86_64.kver

  scala> Module.showDirectories("/boot/grub")
  /boot/grub/i386-pc
  /boot/grub/locale
  /boot/grub/fonts
  /boot/grub/themes

  scala> Module.sayHello()
  Hello world

  scala> Module.code 
  res219: String = xyzfmnk

  scala> Module.code = "hello"
  <console>:13: error: reassignment to val
         Module.code = "hello"
                     ^

  scala> Module.amount += 300

  scala> Module.amount
  res223: Int = 1300


  scala> Module.amount = 0
  Module.amount: Int = 0

  scala> Module.getClass()
  res224: Class[_ <: Module.type] = class Module$
#+END_SRC

** Case class as record 

Example: Simple record type.

#+BEGIN_SRC scala 
  scala> case class Person(id: Int, firstName: String, lastName: String)
  defined class Person

  scala> val p1 = Person(100, "John", "Smith")
  p1: Person = Person(100,John,Smith)

   scala> val p2 = Person(600, "Isaac", "Newton")
  p3: Person = Person(600,Isaac,Newton)

  scala> p1.lastName
  res150: String = Smith

  scala> p1.lastName = ""
  <console>:16: error: reassignment to val
         p1.lastName = ""
                     ^

  scala> List(p1, p2).foreach(println)
  Person(100,John,Smith)
  Person(600,Isaac,Newton)

  scala> List(p1, p2).map(_.firstName)
  res167: List[String] = List(John, Isaac)

  scala> List(p1, p2).map(_.lastName)
  res168: List[String] = List(Smith, Newton)

  scala> 

#+END_SRC

** Creating a Class 

#+BEGIN_SRC scala 

  class Account(owner: String, id: Int, balanceInit: Int)  {

    private var balance = balanceInit

    def getBalance() = balance

    def getId() = id

    def getOwner() = owner

    def deposit(amount: Int) = {
      if (amount < 0)
        error("Erro: Invalid operation. Negative amount of money")
      else 
        balance = balance + amount
    }

    def withdraw(amount: Int) = amount match {
      case a if a > balance
          => error("Error: Not enough funds to withdraw.")

      case a if a < 0
          => error("Erro: Invalid operation. Negative amount of money")

      case _ => balance = balance - amount
    }


    override def toString() = {
      s"Account{id = $id, owner = $owner} = $$ $balance" 
    }

  } // End of class Account


  scala> val account = new Account("Joseph Smith", 10234, 4000)
  account: Account = Account{id = 10234, owner = Joseph Smith} = $ 4000

  // type tab after dot (.) to show all fields and methods
  //
  scala> account.
  deposit   getBalance   getId   getOwner   toString   withdraw

  scala> account.deposit _
  res228: Int => Unit = <function1>

  scala> account.getBalance _
  res229: () => Int = <function0>

  scala> account.getId _
  res230: () => Int = <function0>



  scala> account.toString()
  res180: String = Account{id = 10234, owner = Joseph Smith} = $ 4000

  scala> account.getClass()
  res181: Class[_ <: Account] = class Account


  scala> account.withdraw(300)

  scala> account
  res188: Account = Account{id = 10234, owner = Joseph Smith} = $ 3700

  scala> account.withdraw(10000)
  java.lang.RuntimeException: Error: Not enough funds to withdraw.
    at scala.sys.package$.error(package.scala:27)
    at scala.Predef$.error(Predef.scala:144)
    at Account.withdraw(<console>:24)
    ... 32 elided

  scala> account.withdraw(-100)
  java.lang.RuntimeException: Erro: Invalid operation. Negative amount of money
    at scala.sys.package$.error(package.scala:27)
    at scala.Predef$.error(Predef.scala:144)
    at Account.withdraw(<console>:27)
    ... 32 elided

  scala> account
  res191: Account = Account{id = 10234, owner = Joseph Smith} = $ 3700

  scala> account.deposit(400)

  scala> account
  res193: Account = Account{id = 10234, owner = Joseph Smith} = $ 4100

  scala> account.deposit(-400)
  java.lang.RuntimeException: Erro: Invalid operation. Negative amount of money
    at scala.sys.package$.error(package.scala:27)
    at scala.Predef$.error(Predef.scala:144)
    at Account.deposit(<console>:17)
    ... 32 elided


  scala> account.getOwner()
  res225: String = Joseph Smith

  scala> account.getId()
  res226: Int = 10234


#+END_SRC

** Class with higher order methods 

Scala classes can have methods that accepts functions as parameters or
higher order methods. Note that Scala's collections like List, Array,
Map have higher order methods such as Array.map, Array.foreach and
so on.

Example: 

#+BEGIN_SRC scala 
  class Pipe[A](value: A){
    def p[B](fn: A => B) = new Pipe(fn(value))
    def get() = value
  }


  scala> val v = new Pipe(100.0)
  v: Pipe[Double] = Pipe@d8c6f0

  scala> v.p(_+10).get
  res41: Double = 110.0

  scala> v.p(_+10).p(Math.sin).get
  res42: Double = -0.044242678085070965

  scala> v.p(_+10).p(Math.sin).p(Math.cos).get
  res43: Double = 0.9990214523521718

  scala> v.p(_+10).p(Math.sin).p(Math.cos).p(x => x * 3).get
  res44: Double = 2.9970643570565154

  // Alternative way

  scala> v p(_+10) get
  res47: Double = 110.0

  scala> v p(_+10) p(Math.sin) p(Math.cos) p(x => x * 3) get
  res48: Double = 2.9970643570565154

  { v
    .p(_+10)
    .p(Math.sin)
    .p(Math.cos)
    .p(x => x * 3)
    .get
  }

  scala> { v
       |   .p(_+10)
       |   .p(Math.sin)
       |   .p(Math.cos)
       |   .p(x => x * 3)
       |   .get
       | }
  res49: Double = 2.9970643570565154

  val out = {
    v
    .p(_+10)
    .p(Math.sin)
    .p(Math.cos)
    .p(x => x * 3)
    .get
  }
  out: Double = 2.9970643570565154

#+END_SRC
** Abstract Class 

An abstract class is a class which cannot be instantiated, containing
abstract methods (methods without implementation) and non-abstract
methods .It is intended to be a base class or parent class for sub
classes that will inherit it.

Example: 

#+BEGIN_SRC scala 
  abstract class Shape {
    val name: String 
    def getArea(): Double
    def getPerimiter(): Double
    def scaleDimensions(factor: Double): Unit
  }

  class Rectangle(xx: Double, yy: Double) extends Shape{
    private var x = xx
    private var y = yy

    val name = "Rectangle"

    def getArea() = x * y

    def getPerimiter() = 2.0 * (x + y) 

    def scaleDimensions(factor: Double) = {
      x = factor * x
      y = factor * y
    }

    def getX() = x
    def getY() = y
    def setX(nx: Double) = { x = nx }
    def setY(ny: Double) = { y = ny }

  }


  class Circle(r: Double) extends Shape{
    private var radius = r
    private val pi = 3.1415

    val name = "Circle"

    def getArea() = pi * radius * radius

    def getPerimiter() = 2.0 * pi * radius

    def scaleDimensions(factor: Double) = {
      radius = factor * radius
    }

    def getRadius() = radius

    def setRadius(r: Double) = { radius = r}
  }



  scala> val rec = new Rectangle(10.0, 20.0)
  rec: Rectangle = Rectangle@8f2e3e6

  scala> rec.name
  res9: String = Rectangle

  scala> rec.getX()
  res5: Double = 10.0

  scala> rec.getY()
  res6: Double = 20.0

  scala> rec.getArea()
  res7: Double = 200.0

  scala> rec.getPerimiter()
  res8: Double = 60.0

  scala> rec.scaleDimensions(2.0)

  scala> rec.getX()
  res11: Double = 20.0

  scala> rec.getArea()
  res12: Double = 800.0


  scala> val circ = new Circle(10.0)
  circ: Circle = Circle@169d5567

  scala> circ.name
  res13: String = Circle

  scala> circ.getArea()
  res14: Double = 314.15000000000003

  scala> circ.getPerimiter()
  res15: Double = 62.830000000000005

  scala> circ.getRadius()
  res17: Double = 10.0

  scala> List(circ, rec)
  res18: List[Shape] = List(Circle@169d5567, Rectangle@8f2e3e6)

  scala> List(circ, rec).map(_.name)
  res19: List[String] = List(Circle, Rectangle)

  scala> List(circ, rec).map(_.getArea())
  res20: List[Double] = List(314.15000000000003, 800.0)

  scala> List(circ, rec).map(_.getArea()).sum
  res21: Double = 1114.15


  scala> List(circ, rec).map(_.getPerimiter())
  res23: List[Double] = List(62.830000000000005, 120.0)

  scala> List(circ, rec).map(_.getPerimiter()).sum
  res24: Double = 182.83

#+END_SRC
** Traits 

Traits are similar to java interfaces. A class can inherit only one
class, but can mix multiple traits and must implement the methods and
fields of each trait.

Notes:

 - A trait can have concrete and abstract methods.

 - Traits must not have constructors.

 - Unlike interfaces, traits can have implementation of methods.


#+BEGIN_SRC scala 

  trait Shape {
    def getName(): String
    def getArea(): Double
  }

  trait Location {
    var ox: Double
    var oy: Double
    def move(dx: Double, dy: Double): Unit
    def location(): (Double, Double)
  }

  class Rectangle(w: Double, h: Double) extends Shape with Location {
    var ox = 0.0
    var oy = 0.0 
    def getName() = "rectangle"
    def getArea() = w * h

    def move(dx: Double, dy: Double) = {
      ox = ox + dx
      oy = oy + dy 
    }

    def location() = (ox, oy)

  }

  class Circle(radius: Double) extends Shape with Location {
    var ox = 0.0
    var oy = 0.0 
    def getName() = "circle"
    def getArea() = 3.1415 * radius * radius

    def move(dx: Double, dy: Double) = {
      ox = ox + dx
      oy = oy + dy 
    }

    def location() = (ox, oy)

  }




  scala> val rec = new Rectangle(10.0, 20.0)
  rec: Rectangle = Rectangle@29526c05

  scala> rec.
  getArea   getName   location   move   ox   oy

  scala> rec.getArea()
  res0: Double = 200.0

  scala> rec.getName()
  res1: String = rectangle

  scala> rec.location()
  res2: (Double, Double) = (0.0,0.0)

  scala> rec.move(20.0, 30.0)

  scala> rec.location()
  res4: (Double, Double) = (20.0,30.0)

  scala> rec.move(0.0, 10.0)

  scala> rec.location()
  res6: (Double, Double) = (20.0,40.0)

  scala> 


  scala> val loc: Location = rec
  loc: Location = Rectangle@29526c05

  scala> loc.
  location   move   ox   ox_=   oy   oy_=

  scala> loc.location()
  res7: (Double, Double) = (20.0,40.0)

  scala> loc.ox
  res8: Double = 20.0

  scala> loc.oy
  res9: Double = 40.0

  scala> loc.getName()
  <console>:17: error: value getName is not a member of Location
         loc.getName()
             ^


  scala> val circ = new Circle(10.0)
  circ: Circle = Circle@2ecdcfe3

  scala> circ.getArea()
  res11: Double = 314.15000000000003

  scala> circ.location()
  res12: (Double, Double) = (0.0,0.0)

  scala> circ.move(10.0, 30.0)

  scala> circ.location()
  res14: (Double, Double) = (10.0,30.0)

  scala> circ.move(10.0, 30.0)

  scala> circ.location()
  res16: (Double, Double) = (20.0,60.0)



  scala> List(circ, rec).map(_.getArea())
  res17: List[Double] = List(314.15000000000003, 200.0)

  scala> List(circ, rec).map(_.location())
  res18: List[(Double, Double)] = List((20.0,60.0), (20.0,40.0))

  scala> List(circ, rec).map(_.getName())
  res19: List[String] = List(circle, rectangle)



  def getArea(shape: Shape) = shape.getArea()

  scala> getArea(circ)
  res20: Double = 314.15000000000003

  scala> getArea(rec)
  res21: Double = 200.0

  def getDistance(loc: Location) = Math.sqrt(loc.ox * loc.ox + loc.oy * loc.oy)

  scala> getDistance(circ)
  res22: Double = 63.245553203367585

  scala> getDistance(rec)
  res23: Double = 44.721359549995796

  scala> List(circ, rec).map(getDistance)
  res24: List[Double] = List(63.245553203367585, 44.721359549995796)


#+END_SRC
** OO - Design Patterns 
*** Overview 

GOF - Gang of Four Design Patterns or Design Patterns: Elements of
Reusable Object-Oriented Software (Addison-Wesley Publishing
Company, 1995)

*Design Patterns*

 - *Creational Pattern* - Patterns concerned with object
   instatiation/creation.

   - Factory pattern  
     - Simple Factory
     - Factory Method 

 - *Behavioral Patterns* - Patterns that focus on communication
   between objects.

   - Strategy Pattern - Allows switching algorithm/strategy at run-time.

   - Observer / Publisher-Subscriber

 - *Structural* - Patterns fucusing on objects composition to extend
   its functionality.

*Creational Patterns*

Factory Pattern 

 - Intent: Instantiate classes with a common parent class or interface
   without specifying a concrete class.

Singleton 
 
 - Intent: Ensure that a class with only one instance. 

*Structural Patterns*

Facade Pattern

 - Provide a unified and simplified interface to a complex subsystem.
 
*Behavioral Patterns*

Strategy Pattern

 - Intent: Encapsulate algorithms with objects and switch them at run-time.

Observer Pattern
 
 - Intent: Define one-to-many dependency between objects.

 - Known uses: Event driven-systems such as GUIs such as Gtk, QT and
   Java Swing events or Model in model view controller pattern.

Iterator Pattern 

 - Intent: Access elements of a container without exposing its representation.

 - Known uses: Java Iterators, C++ STL iterators.

*** Simple factory pattern 

Defined by GOF as: "Define an interface for creating an object, but
let subclasses decide which class to instantiate. Factory Method lets
a class defer instantiation to subclasses."

The factory pattern is used to create instances of different
subclasses of a class. A factory class instantiates a subclass based
on the input passed to the factory.

Parts: 

 - Product - Parent class which subclasses will be instantiated by the factory.

 - Factory - Class that instantiate product subclasses. 

The class ComputerFactory is used to instantiate classes that
implements the trait (interface) based on the input passed to the
factory.

Note: This pattern is not extensible since, the class ComputerFactory
needs to be modified for every new Computer subclass.

#+BEGIN_SRC scala 

  trait Computer {
    def getManufacturer(): String
    def getID(): Int
    def clockGHZ: Int

    override def toString() = {
      val m  = getManufacturer()
      val id = getID()
      s"{ Manufacturer = $m id = $id clock = $clockGHZ }"
    }
  }

  class ComputerA extends Computer {
    def getManufacturer() = "SunJitsu"
    def getID()  = 100
    def clockGHZ = 4
  }


  class ComputerB extends Computer {
    def getManufacturer() = "some manufacturer"
    def getID()  = 300
    def clockGHZ = 100
  }


  class ComputerC extends Computer {
    def getManufacturer() = "unknown manufacturer"
    def getID()  = 350
    def clockGHZ = 4
  }

  class ComputerFactory() {
    def getComputer(comp: String) = comp match {
      case "compA" => new ComputerA()
      case "compB" => new ComputerB()
      case "compC" => new ComputerC()
      case _       => error("Error: This type of computer doesn't exist")
    }
  }


  scala> val factory = new ComputerFactory()
  factory: ComputerFactory = ComputerFactory@6acb0d0d

  scala> val compA = factory.getComputer("compA")
  compA: Computer = { Manufacturer = SunJitsu id = 100 clock = 4 }

  scala> compA.getManufacturer()
  res29: String = SunJitsu

  scala> compA.getID()
  res30: Int = 100

  scala> 


  scala> val compB = factory.getComputer("compB")
  compB: Computer = { Manufacturer = some manufacturer id = 300 clock = 100 }

  scala> val compC = factory.getComputer("compC")
  compC: Computer = { Manufacturer = unknown manufacturer id = 350 clok = 4 }

  scala> factory.getComputer("comp")
  java.lang.RuntimeException: Error: This type of computer doesn't exist
    at scala.sys.package$.error(package.scala:27)
    at scala.Predef$.error(Predef.scala:144)
    at ComputerFactory.getComputer(<console>:20)
    ... 32 elided


  scala> List(compA, compB, compC)
  res34: List[Computer] = List({ Manufacturer = SunJitsu id = 100 clok = 4 }, { Manufacturer = some manufacturer id = 300 clok = 100 }, { Manufacturer = unknown manufacturer id = 350 clok = 4 })


  scala> List(compA, compB, compC).foreach(println)
  { Manufacturer = SunJitsu id = 100 clok = 4 }
  { Manufacturer = some manufacturer id = 300 clok = 100 }
  { Manufacturer = unknown manufacturer id = 350 clok = 4 }


  scala> List(compA, compB, compC).map(_.getID())
  res42: List[Int] = List(100, 300, 350)
   
#+END_SRC

Functional Simplification: The factory class can replaces by a
function that instantiates the product sub classes. 

#+BEGIN_SRC scala 
  def getComputer(comp: String) = comp match {
    case "compA" => new ComputerA()
    case "compB" => new ComputerB()
    case "compC" => new ComputerC()
    case _       => error("Error: This type of computer doesn't exist")
  }

  scala> getComputer _
  res46: String => Computer = <function1>


  scala> getComputer("compA")
  res47: Computer = { Manufacturer = SunJitsu id = 100 clock = 4 }


#+END_SRC


References: 

 - *Exploring the Factory Design Pattern*
   <https://msdn.microsoft.com/en-us/library/ee817667.aspx>

 - *Design Pattern - Factory Pattern*
   <https://www.tutorialspoint.com/design_pattern/factory_pattern.htm>

 - *Factory Design Pattern in Java*
   <http://howtodoinjava.com/design-patterns/creational/implementing-factory-design-pattern-in-java/>

 - *Why should I use a factory class instead of direct object
   construction?* -
   <https://softwareengineering.stackexchange.com/questions/253254/why-should-i-use-a-factory-class-instead-of-direct-object-construction>

 - *Factory Pattern* <http://www.oodesign.com/factory-pattern.html>
*** Factory pattern with factory method 

This variation allows multiple subclasses be added to the factory. 

#+BEGIN_SRC scala 

  trait DatabaseDriver {
    def dbname: String
    def connect(Uri: String): Unit
    def createDriver(): DatabaseDriver
  }

  class DbSqlite extends DatabaseDriver {
    val dbname = "sqlite"
    def connect(uri: String) = {
      println("Connect to SQlite database: " + uri)
    }

    def createDriver() = new DbSqlite()
  }


  class DbPostgres extends DatabaseDriver {
    val dbname = "postgres"
    def connect(uri: String) = {
      println("Connect to Postgres database: " + uri)
    }

    def createDriver() = new DbPostgres()
  }



  class DbMysql extends DatabaseDriver {
    val dbname = "mysql"
    def connect(uri: String) = {
      println("Connect to Mysql database: " + uri)
    }

    def createDriver() = new DbMysql()
  }


  class DabaseFactory {
    val dbMap: scala.collection.mutable.Map[String, DatabaseDriver] = scala.collection.mutable.Map()

    def register(driver: DatabaseDriver) = {
      dbMap += (driver.dbname -> driver)
    }

    def getDatabase(dbname: String) = dbMap(dbname).createDriver()
  }


  val dbFactory = new DabaseFactory()

  /// Register database classe.
  dbFactory.register(new DbMysql())
  dbFactory.register(new DbSqlite())
  dbFactory.register(new DbPostgres())




  scala> val sqliteDriver = dbFactory.getDatabase("sqlite")
  sqliteDriver: DatabaseDriver = DbSqlite@41a9920d

  scala> val pgsqlDriver = dbFactory.getDatabase("postgres")
  pgsqlDriver: DatabaseDriver = DbPostgres@1a4b27e1

  scala> val mysqlDriver = dbFactory.getDatabase("mysql")
  mysqlDriver: DatabaseDriver = DbMysql@4f5a3111

  scala> 

  scala> sqliteDriver.dbname
  res61: String = sqlite

  scala> sqliteDriver.connect("file://somedb.sqlite")
  Connect to SQlite database: file://somedb.sqlite

  scala> 

#+END_SRC

Reference: 

  - *Factory Pattern* <http://www.oodesign.com/factory-pattern.html>


  - *what's the difference between a simple factory, a factory method
    design pattern, and an abstract factory?*
    <https://www.linkedin.com/pulse/20140901184348-90925576-what-s-the-difference-between-a-simple-factory-a-factory-method-design-pattern-and-an-abstract-factory>


 - *Simple Factory Vs Factory Method Vs Abstract Factory by Example*
   <https://vivekcek.wordpress.com/2013/03/17/simple-factory-vs-factory-method-vs-abstract-factory-by-example/>

*** Strategy Pattern
**** Overview 

Strategy pattern allows changing the algorithm (strategy) at
run-time. The strategy object encapsulates the algorithm, in other
words, implements the strategy to be executed. The context
object switches its behavior by switching the context object.


Intent: Define a family of algorithms, encapsulate each one, and make
them interchangeable.

This pattern has three main parts:

 - _Strategy_: the interface that defines how the algorithm will be called.

 - _Concrete Strategy_: the implementation of the strategy (algorithm).

 - _Context_: the object holding the Concrete Strategy.


References:

 - Introduction to Design Patterns <https://www.intertech.com/Downloads/Whitepapers/Intertech-Design-Patterns.pdf>

 - Design Patterns - Strategy Pattern <https://www.tutorialspoint.com/design_pattern/strategy_pattern.htm>

 - CS 635 Advanced Object-Oriented Design & Programming - <http://www.eli.sdsu.edu/courses/spring01/cs635/notes/strategy/strategy.html>

 - Strategy pattern - <https://en.wikipedia.org/wiki/Strategy_pattern>

**** Example in OO way

#+BEGIN_SRC scala


  /// Interface for the Strategy - Algorithm
  trait Operation {
    def run(x: Double, y: Double): Double
  }

  /// -------- Concrete strategies ------- ///

  class AddOp() extends Operation {
    def run(x: Double, y: Double) = x + y
  }


  class SubOp extends Operation {
    def run(x: Double, y: Double) = x - y
  }

  class MulOp extends Operation {
    def run(x: Double, y: Double) = x * y
  }

  //----- Context - Class that selects the concrete strategy -- //

  class Context{
    private var strategy: Operation = null

    def setStrategy(strategyS: Operation) = {
      strategy = strategyS
    }

    def runStrategy(x: Double, y: Double) = {
      strategy.run(x, y)
    }

  }


  // ------- Running -------------- //

  scala> val ctx = new Context()
  ctx: Context = Context@2f18e88b

  scala> ctx.setStrategy(new AddOp())

  scala> ctx.runStrategy(10.0, 5.0)
  res69: Double = 15.0

  scala> ctx.setStrategy(new MulOp())

  scala> ctx.runStrategy(63.0, 4.0)
  res71: Double = 252.0

  scala> ctx.setStrategy(new SubOp())

  scala> ctx.runStrategy(63.0, 4.0)
  res73: Double = 59.0

  scala>

#+END_SRC

**** Example in FP way 

In functional programming each _algorithm is just a function_. The
context object can be replaced by a _higher order function_. By the
changing the function argument of the context (higher order function)
its changes the behavior.

Variation 1: Each concrete strategy can become just a function.

#+BEGIN_SRC scala
  type Operation = (Double, Double) => Double

  val addOp: Operation = (x: Double, y: Double) => x + y
  val subOp: Operation = (x: Double, y: Double) => x - y
  val mulOp: Operation = (x: Double, y: Double) => x * y

  class Context{
    private var strategy: Operation = null

    def setStrategy(strategyS: Operation) = {
      strategy = strategyS
    }

    def runStrategy(x: Double, y: Double) = {
      strategy(x, y)
    }
  }


  scala> val ctx = new Context()
  ctx: Context = Context@26275bef

  scala> ctx.setStrategy(addOp)

  scala> ctx.runStrategy(10, 5)
  res1: Double = 15.0

  scala> ctx.setStrategy(mulOp)

  scala> ctx.runStrategy(10, 5)
  res3: Double = 50.0

  scala> ctx.setStrategy(subOp)

  scala> ctx.runStrategy(10, 5)
  res5: Double = 5.0

  scala>

#+END_SRC

Variation 2: With only functions:

 - The function runStrategy switches algorithms at run-time. The
   algorithm is just a function passed as argument.

#+BEGIN_SRC scala

  type Operation = (Double, Double) => Double

  val addOp: Operation = (x: Double, y: Double) => x + y
  val subOp: Operation = (x: Double, y: Double) => x - y
  val mulOp: Operation = (x: Double, y: Double) => x * y

  def runStrategy(strategy: Operation) =  (x: Double, y: Double) => strategy(x, y)


  scala> def runStrategy(strategy: Operation) =  (x: Double, y: Double) => strategy(x, y)
  runStrategy: (strategy: Operation)(Double, Double) => Double

  scala> runStrategy _
  res80: Operation => ((Double, Double) => Double) = <function1>

  scala> runStrategy(addOp)
  res75: (Double, Double) => Double = <function2>

  scala> runStrategy(addOp)(3, 4)
  res76: Double = 7.0

  scala> runStrategy(mulOp)(5, 10)
  res77: Double = 50.0

  scala> runStrategy(subOp)(5, 10)
  res78: Double = -5.0


#+END_SRC

*** Template Method

The templated method design patterns is a behavioral design pattern
which provides an algorithm, also known as template which defines
some steps and defers the implementation of some steps to subclasses. 

It is stated by GOF as: "Defines the skeleton of an algorithm in a
method, deferring some steps to subclasses. Template Method lets
subclasses redefine certain steps of an algorithm without changing the
algorithms structure."

 - Intent: Create an algorithm template that allows redefine some
   steps without changing its structure. 

The parent abstract class has four different types of methods: 

 - Concrete methods: Methods implemented in the abstract class. 

 - Abstract methods: Methods without implementation that must be
   implemented by subclasses. 

 - Hook methods: Methods with default implementation that can be
   overriden by subclasses.

 - Template methods: Method that calls concrete methods, abstract
   methods or hook methods.


Example: The method setepFn is a hook method with default
implementation and the summation is a template method.

#+BEGIN_SRC scala
  trait IntervalSummation {

    // Summation method with default implementation
    def stepFn(a: Int) = a 

    // Summation of all numbers in the interval 
    def summation(lower: Int, upper: Int) = {
      var result = 0 
      for (a <- lower to upper) {
        result = result + stepFn(a)
      }

      result
    }
  }


  scala> class IntervalIdentity extends  IntervalSummation
  defined class IntervalIdentity

  scala> val intervId = new IntervalIdentity()
  intervId: IntervalIdentity = IntervalIdentity@59ede173

  scala> intervId.summation(0, 10)
  res14: Int = 55

  scala> intervId.summation(0, 100)
  res15: Int = 5050



  class IntervalSquare extends  IntervalSummation {
    override def stepFn(a: Int) = a * a
  }

  scala> intervSquare.summation(0, 10)
  res16: Int = 385

  scala> intervSquare.summation(0, 100)
  res17: Int = 338350


  class IntervalCube extends  IntervalSummation {
    override def stepFn(a: Int) = a * a * a 
  }


  scala> intervCube.summation(0, 10)
  res18: Int = 3025

  scala> intervCube.summation(0, 100)
  res19: Int = 25502500


#+END_SRC


References: 

 - *The Template Method Pattern* -
   <http://ima.udg.edu/~sellares/EINF-ES1/TemplateMethodToni.pdf>

 - *Template Method Design Pattern* -
   <https://www.slideshare.net/srikanthps/template-method-design-pattern>

 - *Template Method Design Pattern in Java* -
   <https://stacktips.com/tutorials/design-patterns/template-method-design-pattern-in-java>

 - *Design Patterns - Template Pattern*
   <https://www.tutorialspoint.com/design_pattern/template_pattern.htm>

 - *Template Method Pattern Tutorial with Java Examples*
   <https://dzone.com/articles/design-patterns-template-method>
*** Observer / Publisher Subscriber
    :PROPERTIES:
    :ID:       a24d6fd5-1931-4dde-b68d-0873704614fb
    :END:
**** Overview 

The observer pattern is stated by GOF as "Define a one-to-many
dependency between objects so that when one object changes state, all
its dependents are notified and updated automatically."

The observer pattern is behavioral pattern defining a one-to-many
dependency between subject and observer. The observers objects are
notified about the subject changes.

This pattern is widely used by GUIs toolkits, including Java Swing and
spreadsheets. It is also a key part of MVC - Model View Controller.

It is also known as:

 - Puhlisher/ Subscriber

 - Observable/ Observer

 - Subject / Observer

Known uses in Frameworks:

 - Java: java.util.Observable

 - .NET: System.IObservable and System.IObserver

Participants:

 - _Subject_  - The _subject_ object maintains references to all
   subscribed _observers_ and notifies them when an event happens or
   its state changes.

   - Methods:

     - attach or subscribe           - Attach observer.

     - detach/ unsubscribe or remove - Remove observer.

     - notify - Notify all observers,

 - _Observer_ - Each Observer object has an update or notify method
   that is called by the subscribed subject when its states
   changes.

   - Methods:

     - update / notify  - Notify or update observer.

Mechanisms to send data to observers:

 + Pull model. Observer executes Subject.getData() to get data from subject.

 + Push model. The subject pass its data as argument of observers'
   update method. =for o in observers do o.update(subject.data)=


References:

 - *Observer Pattern*
   <http://www.cs.mcgill.ca/~hv/classes/CS400/01.hchen/doc/observer/observer.html>

 - *Observer Design Pattern*
   <https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern>

 - *Exploring the Observer Design Pattern*
   <https://msdn.microsoft.com/en-us/library/ee817669.aspx>

 - *Introduction to Software Engineering - The Observer Design
   Pattern* <http://stg-tud.github.io/eise/WS11-EiSE-17-Observer_Design_Pattern.pdf>

 - *Observer* <http://cs.unb.ca/~wdu/cs4015/ch5i.pdf>

 - *Observer design pattern*
   <https://www.slideshare.net/saratorkey/observer-design-pattern>

 - *Software Development (cs2500)*
   <http://www.ucccs.info/ucc/ucc2/ucc_folder/cs2500/notes/Lecture%2037%20-%20EventHandlers.pdf>

 - *Observer pattern* <https://en.wikipedia.org/wiki/Observer_pattern>

**** Example in OO way 
     :PROPERTIES:
     :ID:       24e96781-f520-491c-9607-5513cd9c738b
     :END:

Example: A temperature sensor publishes its temperature to 4 observers
that displays the temperature in Celsius, Kelvin and Fahrenheit. It
has also a GUI observer (View) that displays the temperature in
Celsius. All observers(displays, aka views) are updated when the
temperature changes.

 - File:  [[file:src/observerPattern1.scala][src/observerPattern1.scala]] 

#+BEGIN_SRC scala :tangle src/observerPattern1.scala
  // Observer interface
  trait Observer[A] {
    def update(a: A)
  }

  // Subject interface
  trait Subject[A] {
    // Subscribe observer to subject updates
    def attach(obs: Observer[A]): Unit

    // Remove/ unsubscribe observer from subject updates
    def detach(obs: Observer[A]): Unit

    // Notify all observers
    def notifyObservers(a: A): Unit
  }

  // Concrete: Subject
  //----------------------------------
  //
  // Publishes temperature measurements.
  class TempSensor extends Subject[Double]{
    private var temp: Double = 0.0
    private var observers: Set[Observer[Double]] = Set()

    def attach(obs: Observer[Double]) =
      observers += obs

    def detach(obs: Observer[Double]) =
      observers -= obs

    def notifyObservers(tempNew: Double) = {
      temp = tempNew
      observers.foreach(_.update(tempNew))
      // for (obs <- observers) obs.update(tempNew)
    }

    def getTemp() = temp

  }


  // ---------- Concrete Observers ----------------- //

  class ConsoleCelsiusObserver extends Observer[Double]{
    def update(temp: Double) = {
      printf("Current temperature is %.3f in °C\n", temp)
    }
  } // End of class ConsoleCelsiusObserver

  class ConsoleKelvinObserver extends Observer[Double]{
    def update(temp: Double) = {
      printf("Current temperature is %.3f in °K\n", temp + 273.0)
    }
  } // End of class ConsoleKelvinObserver

  class ConsoleFahrenheitObserver(subject: Subject[Double]) extends Observer[Double]{

    init()

    def init() {
      subject.attach(this)
    }

    def update(temp: Double) = {
      val tempF = 5.0 / 9.0 * temp + 32.0
      printf("Current temperature is %.3f in F\n", tempF)
    }
  } // End of class ConsoleFahrenheitObserver


  /// Java Swing Observer
  class GuiCelsiusObserver(subject: Subject[Double]) extends Observer[Double] {
    private var frame   = new javax.swing.JFrame()
    private var display = new javax.swing.JLabel()

    init()

    def init(){
      frame.setSize(255, 71)
      frame.add(display)
      frame.show()
      frame.setTitle("Temperature View")
      subject.attach(this)
    }

    def update(temp: Double) = {
      display.setText("Temperature = %.3f C".format(temp))
    }
  }

  /// ----------- Classes Instantiation ---------- ///

  val sensor = new TempSensor()

  val consoleC = new ConsoleCelsiusObserver()
  sensor.attach(consoleC)

  val consoleK = new ConsoleKelvinObserver()
  sensor.attach(consoleK)

  val consoleF = new ConsoleFahrenheitObserver(sensor)

  val guiObs = new GuiCelsiusObserver(sensor)

#+END_SRC


Running:

#+BEGIN_SRC scala
  scala> :paste src/observerPattern1.scala
  Pasting file src/observerPattern1.scala...
  warning: there was one deprecation warning; re-run with -deprecation for details

  ob_scala_eoldefined trait Observer
  defined trait Subject
  defined class TempSensor
  defined class ConsoleCelsiusObserver
  defined class ConsoleKelvinObserver
  defined class ConsoleFahrenheitObserver
  defined class GuiCelsiusObserver
  sensor: TempSensor = TempSensor@4dd02341
  consoleC: ConsoleCelsiusObserver = ConsoleCelsiusObserver@3212a8d7
  consoleK: ConsoleKelvinObserver = ConsoleKelvinObserver@7a1a3478
  consoleF: ConsoleFahrenheitObserver = ConsoleFahrenheitObserver@495b0487
  guiObs: GuiCelsiusObserver = GuiCelsiusObserver@55dfcc6

  // Manual simulation 
  //-------------------------------

  scala> sensor.notifyObservers(20.0)
  Current temperature is 20.000 in °C
  Current temperature is 293.000 in °K
  Current temperature is 43.111 in F

  scala> sensor.notifyObservers(20.1)
  Current temperature is 20.100 in °C
  Current temperature is 293.100 in °K
  Current temperature is 43.167 in F

  scala> sensor.notifyObservers(20.5)
  Current temperature is 20.500 in °C
  Current temperature is 293.500 in °K
  Current temperature is 43.389 in F

  scala> sensor.detach(consoleK)

  scala> sensor.notifyObservers(23.0)
  Current temperature is 23.000 in °C
  Current temperature is 44.778 in F

  // Automatic simulation
  //--------------------------------------

  def runTimer(interval: Int, taskFn: () => Unit) = {
    val task = new java.util.TimerTask() {
      def run() {
        taskFn()
      }
    }

    val timer = new java.util.Timer()
    // Run the task every 1 second interval (or 1000 milli seconds)
    timer.schedule(task, 1, interval)
    timer
  } // End of runTimer


  // Generates a random number within an interval
  // from (mid - delta) to (mid + delta)
  //
  def genRandomInterval(mid: Double, delta: Double) = {
    val rnd = new java.util.Random()
    () => { val x = rnd.nextDouble()
            2 * delta * x + (mid - delta) 
          }
  }

  scala> def genRandomInterval(mid: Double, delta: Double) = {
       |   val rnd = new java.util.Random()
       |   () => { val x = rnd.nextDouble()
       |           2 * delta * x + (mid - delta) 
       |         }
       | }
  genRandomInterval: (mid: Double, delta: Double)() => Double

  // Generates a temperature between 20.0 - 3.0 (17.0 C) and 20.0 + 3.0 (23 °C)
  scala> val genTemp = genRandomInterval(20.0, 3.0)
  genTemp: () => Double = <function0>


  // Update the temperature every 1 second 
  runTimer(1000, () => sensor.notifyObservers(genTemp()))
#+END_SRC

**** Example in FP way 
     :PROPERTIES:
     :ID:       50b40ac2-98e9-40cb-ab9e-0984e1ef3c22
     :END:

As Scala is a functional language it allows functions be passed
directly as argument, therefore the observer can objects be replaced
by a _callbacks_ function and _subject_ by a mutable collection of
callbacks.

File: [[file:src/observerPatternFun.scala][file:src/observerPatternFun.scala]]

#+BEGIN_SRC scala :tangle src/observerPatternFun.scala
  // Observer object is replace by a callback function 
  type Observer[A] = A => Unit

  // Record containing functions 
  case class Subject[A](
     attach: Observer[A] => Unit
    ,detach: Observer[A] => Unit
    ,notifyObservers: A  => Unit
    ,getState: () => A
  )

  def createSubject[A](stateInit: A) = {
    var observers : Set[A => Unit] = Set()  
    var state = stateInit

    val attach = (obs: Observer[A]) => {
      observers += obs 
    }

    val detach = (obs: Observer[A]) => {
      observers -= obs 
    }

    val notifyObservers = (a: A) => {
      state = a 
      for (obs <- observers) obs(a)
    }

    val getState = () => state

    Subject(attach, detach, notifyObservers, getState)
  }


  // The observer becomes just a function or callback!!
  def consoleCelsiusObserver(temp: Double) = {
    printf("Current temperature is %.3f in °C\n", temp)
  }

  def consoleKelvinObserver(temp: Double) = {
      printf("Current temperature is %.3f in °K\n", temp + 273.0)
  }

  def consoleFahrenheitObserver(temp: Double) = {
    val tempF = 5.0 / 9.0 * temp + 32.0
    printf("Current temperature is %.3f in F\n", tempF)
  }

  // Creates a function that updates the GUI display
  // 
  // Note: (Double => Unit) is optional.
  // The type annotation was added to make reading easier.
  //
  def makeGuiObserver(): (Double => Unit) = {
    val frame = new javax.swing.JFrame()
    val display = new javax.swing.JLabel()
    frame.setSize(255, 71)
    frame.add(display)
    frame.show()
    frame.setTitle("Temperature View")
    (temp: Double) =>  display.setText("Temperature = %.3f C".format(temp))
  }

  val sensor = createSubject[Double](20.0)
  sensor.attach(consoleCelsiusObserver)
  sensor.attach(consoleKelvinObserver)
  sensor.attach(consoleFahrenheitObserver)

  val guiObserver = makeGuiObserver()
  sensor.attach(guiObserver)
#+END_SRC

Running: 

#+BEGIN_SRC scala 
  scala> :paste src/observerPatternFun.scala
  Pasting file src/observerPatternFun.scala...
  warning: there was one deprecation warning; re-run with -deprecation for details

  ob_scala_eoldefined type alias Observer
  defined class Subject
  createSubject: [A](stateInit: A)Subject[A]
  consoleCelsiusObserver: (temp: Double)Unit
  consoleKelvinObserver: (temp: Double)Unit
  consoleFahrenheitObserver: (temp: Double)Unit
  makeGuiObserver: ()Double => Unit
  sensor: Subject[Double] = Subject(<function1>,<function1>,<function1>,<function0>)
  guiObserver: Double => Unit = <function1>


  // Manual simulation
  //--------------------------------------

  scala>  sensor.notifyObservers(21.0)
  Current temperature is 21.000 in °C
  Current temperature is 294.000 in °K
  Current temperature is 43.667 in F

  scala>  sensor.notifyObservers(22.0)
  Current temperature is 22.000 in °C
  Current temperature is 295.000 in °K
  Current temperature is 44.222 in F

  scala>  sensor.notifyObservers(23.0)
  Current temperature is 23.000 in °C
  Current temperature is 296.000 in °K
  Current temperature is 44.778 in F

  scala>  sensor.notifyObservers(25.0)
  Current temperature is 25.000 in °C
  Current temperature is 298.000 in °K
  Current temperature is 45.889 in F


  // Automatic simulation
  //--------------------------------------


  def runTimer(interval: Int, taskFn: () => Unit) = {
    val task = new java.util.TimerTask() {
      def run() {
        taskFn()
      }
    }

    val timer = new java.util.Timer()
    // Run the task every 1 second interval (or 1000 milli seconds)
    timer.schedule(task, 1, interval)
    timer
  } // End of runTimer


  // Generates a random number within an interval
  // from (mid - delta) to (mid + delta)
  //
  def genRandomInterval(mid: Double, delta: Double) = {
    val rnd = new java.util.Random()
    () => { val x = rnd.nextDouble()
            2 * delta * x + (mid - delta) 
          }
  }


  scala> val genTemp = genRandomInterval(20.0, 3.0)
  genTemp: () => Double = <function0>

  scala> genTemp()
  res5: Double = 19.81265553013229

  scala> genTemp()
  res6: Double = 18.965575803660617

  scala> genTemp()
  res7: Double = 21.172101549312305

  scala> genTemp()
  res8: Double = 17.821626339663855

  scala> genTemp()
  res9: Double = 22.38493758505381


  // Update the temperature every 1 second 
  runTimer(1000, () => sensor.notifyObservers(genTemp()))
#+END_SRC

**** Java built-in Observer Pattern 

Java provides the java.util.Observable and java.util.Observer
interfaces to help implement the observer pattern. 

The subject/observable class inherits the Observable interface and
notifies observer objects which implements the Observer interface. 


 - API Docs:

   - [[https://docs.oracle.com/javase/7/docs/api/java/util/Observable.html][Observable (Java Platform SE 7 )]]

   - [[https://docs.oracle.com/javase/7/docs/api/java/util/Observer.html][Observer (Java Platform SE 7 )]]

Example: Every time the temperature sensor gets a new temperature, the
celsius and kelvin displays are updated with the temperature
measurements. 

#+BEGIN_SRC scala 
class TemperatureSensor(initTemp: Double) extends java.util.Observable {
  private var temp = initTemp

  def setValue(t: Double) {
    temp = t
    setChanged()
    notifyObservers()
  }

  def getValue() = temp 
}


// Observer that displays temperature in Celsius 
class CelsiusObserver extends java.util.Observer {
  def update(obs: java.util.Observable, obj: Object){
    val ov = obs.asInstanceOf[TemperatureSensor]
    println("Temperature is = %.2f C".format(ov.getValue()))
  }
}

// Observer that displays temperature in Kelvin 
class KelvinObserver extends java.util.Observer {
  def update(obs: java.util.Observable, obj: Object){
    val ov = obs.asInstanceOf[TemperatureSensor]
    val temp = ov.getValue() + 273.0 
    println("Temperature is = %.2f K".format(temp))
  }
}

val sensor = new TemperatureSensor(21.0)
val celsiusObserver = new CelsiusObserver()
val kelvinObserver  = new KelvinObserver()


sensor.addObserver(celsiusObserver)
sensor.addObserver(kelvinObserver)

cala> sensor.getValue()
res19: Double = 21.0

scala> sensor.setValue(21.5)
Temperature is = 294.50 K
Temperature is = 21.50 C

scala> sensor.setValue(21.6)
Temperature is = 294.60 K
Temperature is = 21.60 C

scala> sensor.setValue(22)
Temperature is = 295.00 K
Temperature is = 22.00 C

scala> 

scala> sensor.countObservers()
res23: Int = 2

scala> sensor.deleteObserver(kelvinObserver)

scala> sensor.setValue(23)
Temperature is = 23.00 C


scala> sensor.deleteObservers()

scala> sensor.setValue(100)

#+END_SRC


References: 

 - *Observer and Observable* An introduction to the Observer interface
   and Observable class using the Model/View/Controller architecture
   as a guide. <http://www.javaworld.com/article/2077258/learn-java/observer-and-observable.html>


 - java.util.Observer Example
   <https://examples.javacodegeeks.com/core-java/util/observer/java-util-observer-example/>

*** Iterator Pattern
**** Overview

The iterator pattern allows tranversing a collection or container
without expose its internal structure and provides a uniform interface
interface to tranverse different types of collections.

 - Stated by GOF as "Provide a way to access the elements of an
   aggregate object sequentially without exposing its underlying
   representation."

Intent: Provide a way to transverse a collection or container
sequentially not exposing its internal representation.


Also known as:

 - Cursor


Iterator Pattern Structure:

 - Iterfaces:

   * Collection
     - Methods:
       + createIterator()   -> Creates a new iterator object specific for the underlying collection.

   * Iterator
     - Methods:
       + hasNext(): Bool  -> Returns true if iterator has next element.
       + next()           -> Get next element and advance to next element.
       + current()        -> Get current element. (Optional)
       + remove()         -> (Optional)

Known uses:

 - This pattern is widely in Java, C# (.NET) and C++ STL containers.

 - Java

   - java.util.Iterator Interface

   - java.util.Enumerator interface

 - .NET

   - IEnumerable

   - IEnumerator

Java iterator Interface:

#+BEGIN_SRC java
  public interface java.util.Iterator<E> {
      boolean hasNext();
      E next();
      void remove();
  }
#+END_SRC


References:

 - *Course Notes — CIS 501: Software Architecture and Design, Fall
   2014*
   <http://softwarearch.santoslab.org/12-design-patterns-factories-iterators/index.html>

 - *Supplement: Design Patterns. For Introduction to Java
   Programming* -
   <http://www.cs.armstrong.edu/liang/apcs/supplement/Supplement5hDesignpatterns.pdf>

 - *Iterator Pattern Tutorial with Java Examples*
   <https://dzone.com/articles/design-patterns-iterator>

 - *Iterator* <http://www.oodesign.com/iterator-pattern.html>

 - *Design Patterns - Iterator Pattern*
   <https://www.tutorialspoint.com/design_pattern/iterator_pattern.htm>

 - *Principles of Software Construction: Objects, Design, and
   Concurrency; Design Case Study: Stream I/O*
   <https://www.cs.cmu.edu/~charlie/courses/15-214/2014-fall/slides/14-io.pdf>

 - *The Use of Iterator Iterator in Python* <https://www.codeday.top/2017/03/27/21392.html>

 -

**** Examples

Example 1 - Java built-in iterator.

#+BEGIN_SRC scala
  scala> import java.util.Arrays
  import java.util.Arrays


  scala> val arr = Arrays.asList(1, 2, 3, 4, 5, 6, 7)
  arr: java.util.List[Int] = [1, 2, 3, 4, 5, 6, 7]

  scala> val iter = arr.iterator()
  iter: java.util.Iterator[Int] = java.util.AbstractList$Itr@3030836d

  scala> iter.hasNext _
  res2: () => Boolean = <function0>

  scala> iter.next _
  res3: () => Array[Int] = <function0>

  scala> iter.remove _
  res4: () => Unit = <function0>

  scala> iter.hasNext()
  res8: Boolean = true

  scala> iter.next()
  res9: Int = 1

  scala> iter.hasNext()
  res10: Boolean = true

  scala> iter.next()
  res11: Int = 2

  scala> iter.next()
  res12: Int = 3

  scala> iter.next()
  res13: Int = 4

  scala> iter.next()
  res14: Int = 5

  scala> iter.hasNext()
  res15: Boolean = true

  scala> iter.next()
  res16: Int = 6

  scala> iter.hasNext()
  res17: Boolean = true

  scala> iter.next()
  res18: Int = 7

  scala> iter.hasNext()
  res19: Boolean = false

  scala> iter.next()
  java.util.NoSuchElementException
    at java.util.AbstractList$Itr.next(AbstractList.java:364)
    ... 32 elided

  scala>

#+END_SRC

Example 2 - Print all collection elements

#+BEGIN_SRC scala
  scala> import java.util.Arrays
  import java.util.Arrays

  scala> val arr = Arrays.asList(1, 2, 3, 4, 5, 6, 7)
  arr: java.util.List[Int] = [1, 2, 3, 4, 5, 6, 7]

  scala> val iter = arr.iterator()
  iter: java.util.Iterator[Int] = java.util.AbstractList$Itr@210d3a42

  while (iter.hasNext()) {
    println(iter.next())
  }

  scala> while (iter.hasNext()) {
       |   println(iter.next())
       | }
  1
  2
  3
  4
  5
  6
  7
#+END_SRC

Example 3: Implementation a range iterator with java.util.iterator interface.

#+BEGIN_SRC scala

  class RangeIterator(from: Double, to: Double, step: Double) extends java.util.Iterator[Double] {
    private var cursor = from

    def hasNext() = cursor < to

    def next() = {
      if (!hasNext())
        error("Error: End of iteration, no more elements available.")
      else
      { val ret = cursor
        cursor = cursor + step
        ret
      }
    }

    def remove() = error("Error: Method not implemented")

  }


  scala> val rng = new RangeIterator(0.0, 5.0, 1.0)
  rng: RangeIterator = RangeIterator@1a6df932

  scala> rng.next()
  res41: Double = 0.0

  scala> rng.hasNext()
  res42: Boolean = true

  scala> rng.next()
  res43: Double = 1.0

  scala> rng.hasNext()
  res44: Boolean = true

  scala> rng.next()
  res45: Double = 2.0

  scala> rng.hasNext()
  res46: Boolean = true

  scala> rng.next()
  res47: Double = 3.0

  scala> rng.next()
  res48: Double = 4.0

  scala> rng.hasNext()
  res49: Boolean = false

  scala> rng.next()
  java.lang.RuntimeException: Error: End of iteration, no more elements available.
    at scala.sys.package$.error(package.scala:27)
    at scala.Predef$.error(Predef.scala:144)
    at RangeIterator.next(<console>:19)
    ... 32 elided

  scala>



  val iter = new RangeIterator(0.0, 10.0, 1.0)

  while (iter.hasNext()) {
    println(iter.next())
  }

  scala> while (iter.hasNext()) {
       |   println(iter.next())
       | }
  0.0
  1.0
  2.0
  3.0
  4.0
  5.0
  6.0
  7.0
  8.0
  9.0

#+END_SRC

Example 4: Creating an iterator to iterate over file lines.

#+BEGIN_SRC scala

  class ReadFileLinesIterator(file: String) extends Iterator[String] {
    private var buf          = new java.io.BufferedReader(new java.io.FileReader(file))
    private var line: String = ""
    private var status       = true

    init()

    def init() {
      line = buf.readLine()
      status = line != null
    }

    def hasNext() = status

    def next() = {
      if (hasNext())
        {
          val ret = line
          line = buf.readLine()
          status = line != null
          ret
        }
      else
        error("Error: End of iteration. No more elements available.")
    }

    def remove() = error("Error: invalid method for this iterator.")
  }



  scala> val lineIter = new ReadFileLinesIterator("/etc/lsb-release")
  lineIter: ReadFileLinesIterator = non-empty iterator

  scala> lineIter.hasNext()
  res78: Boolean = true

  scala> lineIter.next()
  res79: String = DISTRIB_ID=ManjaroLinux

  scala> lineIter.hasNext()
  res80: Boolean = true


  scala> lineIter.next()
  res81: String = DISTRIB_RELEASE=17.0.1

  scala> lineIter.hasNext()
  res82: Boolean = true

  scala> lineIter.next()
  res83: String = DISTRIB_CODENAME=Gellivara

  scala> lineIter.hasNext()
  res84: Boolean = true

  scala> lineIter.next()
  res85: String = DISTRIB_DESCRIPTION="Manjaro Linux"

  scala> lineIter.next()
  java.lang.RuntimeException: Error: End of iteration. No more elements available.
    at scala.sys.package$.error(package.scala:27)
    at scala.Predef$.error(Predef.scala:144)
    at ReadFileLinesIterator.next(<console>:35)
    ... 32 elided

  scala> lineIter.hasNext()
  res87: Boolean = false

  scala>

  val lineIter = new ReadFileLinesIterator("/etc/lsb-release")
  while(lineIter.hasNext()){
    println(lineIter.next())
  }


  scala> while(lineIter.hasNext()){
       |   println(lineIter.next())
       | }
  DISTRIB_ID=ManjaroLinux
  DISTRIB_RELEASE=17.0.1
  DISTRIB_CODENAME=Gellivara
  DISTRIB_DESCRIPTION="Manjaro Linux"


#+END_SRC

*** Model View Controller - MVC 
**** Overview 

The MVC - Model-View-Controller pattern was introduced by Trygve
Reenskaug in a Smalltalk-80 implementation in 1970s to address the
problem of building GUI - Graphical User Interfaces.

The MVC has three parts: 

 - _View_ - The view is everything the user can see and it is
   resposible to render the model data. It is built with a hierarchy of
   widgets of some GUI toolkit such as Gtk, QT, Java Swing and etc.

   + _Manages graphical or textual output._

 - _Controller_ - The controller is a middleware between the view and
   model. The controller handles the user input or the events
   triggered by the view updating the model or the view.

   + _Manages user input_ or GUI events such as button click, mouse move
     and etc.  

 - _Model_ - The model contains data to be displayed by the view and
   the business logic.

   + _Manages application logic or domain logic._

   + The model must have no knowledge about the view or controller.

   + A model can have multiple views diplaying the model in different
     ways. Example bar chart, pie chart, table, spreadsheet display
     and so on. Each view must have an associated controller.

   + When the model is updated, it notifies all views that it has
     changed and the views query data from the model updating
     itself. The model is suitable to be implemented with observer
     pattern. 

   + The MVC is supposed to have only one global model.

[[file:images/mvc-model-view-controller-diagram.png][file:images/mvc-model-view-controller-diagram.png]]

MVC Variation: 

 - Controller as mediator or MVP - Model View Presenter. The model
   doesn't interact directly with the view. It updates the view
   through the controller. This MVC variation is widely used in
   Apple's Cocoa framework.


Benefits: 

 - Separate the domain model from the presentation.

 - The same data can be displayed or rendered in many different
   ways. Multiple views for short.

Drawbacks: 

 - In a GUI it is hard to separate input from output, consequently it
   is hard to separate  the view from the model. What makes them
   tightly coupled.


References and Bookmarks: 

 - *MVP: Model-View-Presenter. The Taligent Programming Model for C++
   and Java* <https://web.archive.org/web/20170620100654/http://www.wildcrest.com/Potel/Portfolio/mvp.pdf>

 - *A Description of the Model-View-Controller User Interface Paradigm
   in the Smalltalk-80 System*
   <https://web.archive.org/web/20170620095511/http://www.global-webnet.com/Adventures/Files/DescriptionOfMvcUi-KrasnerPope.pdf>

 - *Java SE Application Design With MVC*
   <https://web.archive.org/web/20070309124616/http://java.sun.com/developer/technicalArticles/javase/mvc/>

 - *ARTICLE TITLE: You’ve got the model-view-controller*
   <https://web.archive.org/web/20170620142643/http://cs.txstate.edu/~rp31/papers/Model-View-Controller.PDF>

 - *Model View Controller* <http://wiki.c2.com?ModelViewController>

 - *Model-View-Controller paradigm; Observer pattern; Creating
   Graphical User Interfaces in Java/Swing* -
   <https://drive.google.com/viewerng/viewer?url=http://faculty.washington.edu/stepp/courses/2005spring/tcss360/lectures/notes/08-gui_mvc_observer.ppt>

 - *Model-View-Controller Pattern* -
   <http://academic.regis.edu/dbahr/generalpages/softwareengineering/softwareengpart17.pdf>

Apple's "MVC": 

 - *Guides and Samples - Model-View-Controller*
   <https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html>


 - *Looking at Model-View-Controller in Cocoa*
   <https://www.cocoawithlove.com/blog/mvc-and-cocoa.html>

Sample codes and examples:

 - *Model-View-Controller (MVC) Structure*
   <https://www.leepoint.net/GUI/structure/40mvc.html>

 - *Lecture 6: Coupling and the MVC software architecture*
   <https://web.archive.org/web/20170620171835/http://people.cs.ksu.edu/~schmidt/501s14/Lectures/Lecture06S.html>

 - *Building Games Using the MVC Pattern – Tutorial and Introduction*
   <https://www.javacodegeeks.com/2012/02/building-games-using-mvc-pattern.html>

 - *Sliding Clock Using Java Swing* <http://java-articles.info/articles/?p=885>
 

Java Swing: 

 - *Java Programming Tutorial. Programming Graphical User Interface
   (GUI) - Part 2* <https://www3.ntu.edu.sg/home/ehchua/programming/java/J4a_GUI_2.html>

History: 

 - *Next Step* <http://wiki.c2.com?NextStep>

 - *Open Step* <http://wiki.c2.com?OpenStep>

**** Example 

This example shows a simple GUI application with MVC and Java Swing
toolkit using three views, one console view that prints the model
state and two Java swing GUI views.

File: [[file:src/mvcCounter.scala][file:src/mvcCounter.scala]]

#+BEGIN_SRC scala 
  import javax.swing.{JFrame, JPanel, JTextField, JButton, JLabel}


  //-----------  Observer Pattern Interfaces ----------- //

  // Observer interface 
  trait Observer {
    def update(): Unit
  }

  // Subject or Observable interface 
  trait Observable {

    private var observers: Set[Observer] = Set()

    // Subscribe observer to subject updates 
    def attach(obs: Observer) {
      observers += obs 
    }

    // Remove/ unsubscribe observer from subject updates 
    def detach(obs: Observer) {
      observers -= obs 
    }

    // Notify all observers 
    def notifyObservers() {
      for (obs <- observers) obs.update() 
    }
  }


  //----------- Helpers to subscribe to events ------------- //

  /// Register callback function
  ///
  def onClick(button: JButton) (handler: () => Unit) = {
    button.addActionListener(
      new java.awt.event.ActionListener(){
        def actionPerformed(evt: java.awt.event.ActionEvent) = {
          handler()
        }
      }
    )
  }


  def onWindowExit(frame: javax.swing.JFrame) (handler: () => Unit) = {
    frame.addWindowListener(
      new java.awt.event.WindowAdapter(){
        override def windowClosing(evt: java.awt.event.WindowEvent) = {
          handler()
        }
    })
  }

  def showFrameSize(frame: javax.swing.JFrame){
    println(frame.getSize())
  }


  //--------------- MVC Counter Demo -------------------- // 


  class CounterModel(init: Int) extends Observable{
    private var counter = init

    def getValue() = counter

    def increment() = {
      counter = counter + 1   // Every time the model state is changed,
                              // the observers must be notified.

      this.notifyObservers()  // the 'this' prefix is optional.
    }

    def decrement() = {
      counter = counter - 1
      this.notifyObservers()  
    } 
  }

  /// This view doesn't need a controller as this doesn't need an input.
  class ConsoleView(counter: CounterModel) extends Observer{
    init()

    def init(){
      // Register observer (this class)
      counter.attach(this)
    }

    // updates the view 
    def update() {
      println("Counter value is = " + counter.getValue())
    }
  }


  class GuiView1(counter: CounterModel) extends Observer{
    private val frame   = new JFrame("Counter MVC App")
    private val panel   = new JPanel(new java.awt.FlowLayout())
    private val label   = new JLabel("Counter")
    private val display = new JTextField(10)
    private val btnInc  = new JButton("Increment")
    private val btnDec  = new JButton("Decrement")
    private val btnExit = new JButton("Exit")

    init()

    def init(){
      // Register observer (this class)
      counter.attach(this)

      panel.add(label)
      panel.add(display)
      panel.add(btnInc)
      panel.add(btnDec)
      panel.add(btnExit)

      display.setEditable(false)
      frame.add(panel)
      frame.setSize(600, 100)
      frame.show()

      // Exit application if user closes window.
      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)

      this.update()
    }

    // updates the view 
    def update() {
      display.setText(counter.getValue().toString())
    }

    def onIncrement(handler: () => Unit) {
      onClick(btnInc)(handler)
    }

    def onDecrement(handler: () => Unit) {
      onClick(btnDec)(handler)
    }

    def onExit(handler: () => Unit) = {
      onClick(btnExit)(handler)
    }

    def show(){
      frame.show()
    }
  }

  class GuiView1Controller(viewp: GuiView1, modelp: CounterModel){
    private var view  = viewp
    private var model = modelp
    init()

    def init(){
      
      //---> Model Manipulation 
      view.onIncrement(this.increment)
      view.onDecrement(this.decrement)

      //---> GUI manipulation 
      view.onExit(() => System.exit(0))
    }

    def increment(){
      model.increment()
    }

    def decrement(){
      model.decrement()
    }

  }

  // View without input that only displays the model.
  // This view doesn't need a controller as it doesn't
  // have any user input.
  //
  class GuiView2(counter: CounterModel) extends Observer{
    private val frame   = new JFrame("Counter App - Display only view")
    private val panel   = new JPanel()
    private val display = new JLabel()

    init()

    def init(){
      counter.attach(this)

      panel.add(display)
      frame.setSize(354, 54)
      frame.add(panel)
      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)
      frame.show()
      update()
    }

    // Method required by Observer interface 
    def update(){
      display.setText(counter.getValue().toString())
      // showFrameSize(frame)
    }
  }


  val counterModel = new CounterModel(0)
  val consoleView  = new ConsoleView(counterModel)

  val guiView1           = new GuiView1(counterModel)
  val guiView1Controller = new GuiView1Controller(guiView1, counterModel)

  val guiView2           = new GuiView2(counterModel)

#+END_SRC

Running: 

#+BEGIN_SRC text 
$ scala mvcCounter.scala 
warning: there were three deprecation warnings; re-run with -deprecation for details
one warning found
Counter value is = 1
Counter value is = 2
Counter value is = 3
Counter value is = 4
... ... 
#+END_SRC

[[file:images/counterMvcExample.png][file:images/counterMvcExample.png]]
*** Model View Presenter with Passive View - MVP 
**** Overview 

The MVP - Model-View-Presenter is variation of MVC
Model-View-Controller which the model doesn't communicate directly
with the view and it is made passive. This pattern is often designated
as MVC.

#+BEGIN_SRC text 
           View event triggered
           by user.
           
           +.....->>>-.......+            +........<<<<..........+
          /  (User action)    \          /   Model notification   \ 
         /                     \        /    event                 \   
      View                     Presenter                          Model
        \                      /       \                           /
         \   View update      /         \     Model update        /
          +----<<<-----------/           +--->>>------>>>--------+

  Legend: 
   
   ...... - Event or notification
   ------ - Method call or action.
  
#+END_SRC


 - _Model_

   + The model is responsible for the business logic or domain logic
     and application state.

   + As in the MVC, the model must have no knowledge about the view or
     presenter.

   + Unlike the MVC, the model must not communicate directly with the
     view, instead it must notify the presenter that it has
     changed. It can be done using the observer pattern with the model
     playing the role of observable or observer and the presenter
     acting as observer.

 - _View_

   + The view role is display the model.

   + Passive view:

     * The view must not have any knowledge about the model and not
       access it directly.

     * The view doesn't update itself from the model. It is updated by
       the presenter.

     * The view delegates use input events to the presenter.

 - _Presenter_

   + The presenter role is to handle the presentation logic and
     mediate the communication between the model and view updating the
     view with the model data and also handling view events and model
     notifications. 

   + Presenter - View communication:

     * The presenter handles events received from the view
       and manipulates the view or the model.

   + Presenter - Model communication:

     + The presenter receives notifications from the model and updates
       the view with model data in suitable format to the view. 


References and Bookmarks: 

 - Martin Fowler. *Pasive View* <https://martinfowler.com/eaaDev/PassiveScreen.html>

 - Andy Bower and Blair McGlashan. *The evolution of the Dolphin
   Smalltalk MVP application framework.*
   <https://web.archive.org/web/20170622165759/http://www.object-arts.com/downloads/papers/TwistingTheTriad.PDF>

 - *Tutorial 5: MVC Patterns*
   <http://griffon-framework.org/tutorials/5_mvc_patterns.html> or
   <https://web.archive.org/web/20170622172050/http://griffon-framework.org/tutorials/5_mvc_patterns.html>

 - Yang Zhang and Yanjing Luo *An Architecture and Implement Model for
   Model-View-Presenter Pattern*
   <https://web.archive.org/web/20170622174219/http://www.meeting.edu.cn/meeting/UploadPapers/1282707447171.pdf>

 - *Model-View-Presenter: Looking at Passive View* <http://blogs.lessthandot.com/index.php/architect/designingsoftware/model-view-presenter-looking-at-passive/>

 - Aviad Ezra. *Twisting the MVC Triad - Model View Presenter (MVP)
   Design Pattern*
   <http://aviadezra.blogspot.com.br/2007/07/twisting-mvp-triad-say-hello-to-mvpc.html>
   or <https://web.archive.org/web/20170622180300/http://aviadezra.blogspot.com.br/2007/07/twisting-mvp-triad-say-hello-to-mvpc.html>

 - Apple Inc. *Concepts in Objective-C Programming - Model-View-Controller*
   <https://web.archive.org/web/20170622181821/https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html>

 - *Model-View-Controller rationale, implementation, abstract model
   widgets* <https://web.archive.org/web/20170622183803/https://www.student.cs.uwaterloo.ca/~cs349/s14/files/04.mvc.3up.pdf>
**** Example 

This example is similar to the MVC counter example.

File: [[file:src/mvpCounter.scala][file:src/mvpCounter.scala]] 

#+BEGIN_SRC scala :tangle src/mvpCounter.scala
import javax.swing.{JFrame, JPanel, JTextField, JButton, JLabel}


//-----------  Observer Pattern Interfaces ----------- //

// Observer interface 
trait Observer {
  def update(): Unit
}

// Subject or Observable interface 
trait Observable {

  private var observers: Set[Observer] = Set()

  // Subscribe observer to subject updates 
  def attach(obs: Observer) {
    observers += obs 
  }

  // Remove/ unsubscribe observer from subject updates 
  def detach(obs: Observer) {
    observers -= obs 
  }

  // Notify all observers 
  def notifyObservers() {
    for (obs <- observers) obs.update() 
  }
}


//----------- Helpers to subscribe to events ------------- //

/// Register callback function
///
def onClick(button: JButton) (handler: () => Unit) = {
  button.addActionListener(
    new java.awt.event.ActionListener(){
      def actionPerformed(evt: java.awt.event.ActionEvent) = {
        handler()
      }
    }
  )
}


def onWindowExit(frame: javax.swing.JFrame) (handler: () => Unit) = {
  frame.addWindowListener(
    new java.awt.event.WindowAdapter(){
      override def windowClosing(evt: java.awt.event.WindowEvent) = {
        handler()
      }
  })
}


//--------------- MVP Counter Demo -------------------- //



class CounterModel(init: Int) extends Observable{
  private var counter = init

  def getValue() = counter

  def increment() = {
    counter = counter + 1   // Every time the model state is changed,
                            // the observers must be notified.

    this.notifyObservers()  // the 'this' prefix is optional.
  }

  def decrement() = {
    counter = counter - 1
    this.notifyObservers()  
  } 
}



class CounterView extends {
  private val frame   = new JFrame("Counter MVC App")
  private val panel   = new JPanel(new java.awt.FlowLayout())
  private val label   = new JLabel("Counter")
  private val display = new JTextField(10)
  private val btnInc  = new JButton("Increment")
  private val btnDec  = new JButton("Decrement")
  private val btnExit = new JButton("Exit")

  init()

  def init(){
    panel.add(label)
    panel.add(display)
    panel.add(btnInc)
    panel.add(btnDec)
    panel.add(btnExit)

    display.setEditable(false)
    frame.add(panel)
    frame.setSize(600, 100)
    // Exit application if user closes window.
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)   
  }

  // updates the view 
  def setDisplay(value: String) {
    display.setText(value)
  }

  def onIncrement(handler: () => Unit) {
    onClick(btnInc)(handler)
  }

  def onDecrement(handler: () => Unit) {
    onClick(btnDec)(handler)
  }

  def onExit(handler: () => Unit) = {
    onClick(btnExit)(handler)
  }

  def show(){
    frame.show()
  }
}



class CounterPresenter(model: CounterModel) extends Observer{
  private val view  = new CounterView()

  init()

  def init(){

    // Subscribe presenter to model updates 
    model.attach(this)

    //---> Model Manipulation 
    view.onIncrement(this.increment)
    view.onDecrement(this.decrement)

    //---> GUI manipulation 
    view.onExit(() => System.exit(0))

    // Initial model display
    this.update()
  }

  def increment(){
    model.increment()
  }

  def decrement(){
    model.decrement()
  }

  // Method required by Observer interface. It updates the view
  // when the model notifies the presenter that its state has
  // changed.
  def update(){
    view.setDisplay(model.getValue().toString())
  }

  def show() = view.show()

}


val counterModel = new CounterModel(0)
val presenter    = new CounterPresenter(counterModel)
presenter.show()

#+END_SRC
* Java Interoperability
** Show Java Properties

#+BEGIN_SRC scala
scala>  System.getProperty ("java.vm.vendor")
res2: String = Oracle Corporation

scala>  System.getProperty ("java.home")
res3: String = /usr/lib/jvm/java-8-openjdk/jre

scala>  List("java.vm.vendor", "java.home", "java.runtime.name", "java.vm.name").map(System.getProperty)
res4: List[String] = List(Oracle Corporation, /usr/lib/jvm/java-8-openjdk/jre, OpenJDK Runtime Environment, OpenJDK 64-Bit Server VM)

scala>  val xs = List("java.vm.vendor", "java.home", "java.runtime.name", "java.vm.name")
xs: List[String] = List(java.vm.vendor, java.home, java.runtime.name, java.vm.name)

scala>  xs.foreach(p => println ("%s\t%s".format(p, System.getProperty(p))))
java.vm.vendor	Oracle Corporation
java.home	/usr/lib/jvm/java-8-openjdk/jre
java.runtime.name	OpenJDK Runtime Environment
java.vm.name	OpenJDK 64-Bit Server VM

#+END_SRC
** Java Reflection
*** Show Class Method given a class name

See: [[http://gauss.ececs.uc.edu/Courses/c4003/java/Reflection/reflection0.html][Reflection]]

#+BEGIN_SRC scala

scala> Class.forName("java.io.File").getDeclaredMethods().take(10).foreach(println)
public boolean java.io.File.equals(java.lang.Object)
public java.lang.String java.io.File.toString()
public int java.io.File.hashCode()
public int java.io.File.compareTo(java.lang.Object)
public int java.io.File.compareTo(java.io.File)
public java.lang.String java.io.File.getName()
public long java.io.File.length()
public java.lang.String java.io.File.getParent()
public boolean java.io.File.isAbsolute()
public java.lang.String java.io.File.getCanonicalPath() throws java.io.IOException

def show_class_methods (classname: String) {
  Class
    .forName(classname)
    .getDeclaredMethods()
    .foreach(println)
}

show_class_methods: (classname: String)Unit

scala> show_class_constructors("javax.swing.JFrame")
protected void javax.swing.JFrame.frameInit()
protected javax.swing.JRootPane javax.swing.JFrame.createRootPane()
protected void javax.swing.JFrame.processWindowEvent(java.awt.event.WindowEvent)
public void javax.swing.JFrame.setDefaultCloseOperation(int)
public int javax.swing.JFrame.getDefaultCloseOperation()
public void javax.swing.JFrame.setTransferHandler(javax.swing.TransferHandler)
public javax.swing.TransferHandler javax.swing.JFrame.getTransferHandler()
public void javax.swing.JFrame.setJMenuBar(javax.swing.JMenuBar)
public javax.swing.JMenuBar javax.swing.JFrame.getJMenuBar()
...

def show_class_constructors (classname: String) {
  Class
    .forName(classname)
    .getDeclaredConstructors()
    .foreach(println)
}

scala> show_class_constructors("java.io.File")
public java.io.File(java.lang.String,java.lang.String)
public java.io.File(java.lang.String)
private java.io.File(java.lang.String,java.io.File)
public java.io.File(java.io.File,java.lang.String)
public java.io.File(java.net.URI)
private java.io.File(java.lang.String,int)

scala> Class.forName("java.io.File").getDeclaredFields().foreach(println)
private static final java.io.FileSystem java.io.File.fs
private final java.lang.String java.io.File.path
private transient java.io.File$PathStatus java.io.File.status
private final transient int java.io.File.prefixLength
public static final char java.io.File.separatorChar
public static final java.lang.String java.io.File.separator
public static final char java.io.File.pathSeparatorChar
public static final java.lang.String java.io.File.pathSeparator
private static final long java.io.File.PATH_OFFSET
private static final long java.io.File.PREFIX_LENGTH_OFFSET
private static final sun.misc.Unsafe java.io.File.UNSAFE
private static final long java.io.File.serialVersionUID
private transient volatile java.nio.file.Path java.io.File.filePath
static final boolean java.io.File.$assertionsDisabled


#+END_SRC

*** Show Object Methods

#+BEGIN_SRC scala
def showObjectMethods(obj: Any) = {
    obj.getClass().getDeclaredMethods().foreach(println)
}
#+END_SRC

Test:

#+BEGIN_SRC scala
scala> import scala.io.Source
import scala.io.Source

scala> import java.net.URL
import java.net.URL

scala> val url = new URL("http://www.httpbin.org/get")
url: java.net.URL = http://www.httpbin.org/get


scala> showObjectMethods(url)
public boolean java.net.URL.equals(java.lang.Object)
public java.lang.String java.net.URL.toString()
public synchronized int java.net.URL.hashCode()
public final java.io.InputStream java.net.URL.openStream() throws java.io.IOException
private synchronized void java.net.URL.readObject(java.io.ObjectInputStream) throws java.io.IOException,java.lang.ClassNotFoundException
private synchronized void java.net.URL.writeObject(java.io.ObjectOutputStream) throws java.io.IOException
void java.net.URL.set(java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)
void java.net.URL.set(java.lang.String,java.lang.String,int,java.lang.String,java.lang.String)
private java.lang.Object java.net.URL.readResolve() throws java.io.ObjectStreamException
public java.lang.String java.net.URL.getPath()
public java.net.URI java.net.URL.toURI() throws java.net.URISyntaxException
public java.lang.String java.net.URL.getAuthority()
public java.lang.String java.net.URL.getQuery()
public java.net.URLConnection java.net.URL.openConnection(java.net.Proxy) throws java.io.IOException
public java.net.URLConnection java.net.URL.openConnection() throws java.io.IOException
public java.lang.String java.net.URL.getProtocol()
public java.lang.String java.net.URL.getFile()
public java.lang.String java.net.URL.getHost()
...
#+END_SRC
*** Show Object Public Methods

#+BEGIN_SRC java
  import java.lang.reflect.Modifier

  def showObjPublicMethods (obj: Any) {
      for (m <- url.getClass().getDeclaredMethods()
               if Modifier.isPublic(m.getModifiers)
           ) println(m)
  }
#+END_SRC

Example:

#+BEGIN_SRC scala

scala> import java.net.URL
import java.net.URL


scala> showObjPublicMethods(url)

public boolean java.net.URL.equals(java.lang.Object)
public java.lang.String java.net.URL.toString()
public synchronized int java.net.URL.hashCode()
public final java.io.InputStream java.net.URL.openStream() throws java.io.IOException
public java.lang.String java.net.URL.getPath()
public java.net.URI java.net.URL.toURI() throws java.net.URISyntaxException
public java.lang.String java.net.URL.getAuthority()
public java.lang.String java.net.URL.getQuery()
public java.net.URLConnection java.net.URL.openConnection(java.net.Proxy) throws java.io.IOException
public java.net.URLConnection java.net.URL.openConnection() throws java.io.IOException
public java.lang.String java.net.URL.getProtocol()
public java.lang.String java.net.URL.getFile()
public java.lang.String java.net.URL.getHost()
public java.lang.String java.net.URL.getUserInfo()
public int java.net.URL.getPort()
public int java.net.URL.getDefaultPort()
public java.lang.String java.net.URL.getRef()
public boolean java.net.URL.sameFile(java.net.URL)
public java.lang.String java.net.URL.toExternalForm()
public final java.lang.Object java.net.URL.getContent(java.lang.Class[]) throws java.io.IOException
public final java.lang.Object java.net.URL.getContent() throws java.io.IOException
public static void java.net.URL.setURLStreamHandlerFactory(java.net.URLStreamHandlerFactory)
#+END_SRC
*** Show Object's Public Method Names

#+BEGIN_SRC scala
  import java.lang.reflect.Modifier

  def showObjMethodNames (obj: Any){
    for (m <- obj.getClass().getDeclaredMethods()
         if Modifier.isPublic(m.getModifiers)
    ) println(m.getName())
  }
#+END_SRC

Example:

#+BEGIN_SRC scala
scala> showObjMethodNames(url)
equals
toString
hashCode
openStream
getPath
toURI
getAuthority
getQuery
openConnection
openConnection
getProtocol
getFile
getHost
...
#+END_SRC

** GUI - Graphical User Interface (Java Swing)
*** Messagebox
    :PROPERTIES:
    :ID:       5af1203e-51cc-4501-a2a6-a47673ebd8a8
    :END:

 - File: [[file:src/messageBox.scala][file:src/messageBox.scala]] 

#+BEGIN_SRC scala :tangle src/messageBox.scala
  def messageBox (title: String, content: String) {
    javax.swing.JOptionPane.showMessageDialog (
      null,
      content,
      title,
      javax.swing.JOptionPane.PLAIN_MESSAGE
    )
   }

  messageBox("Information", "Download of file animation.jar completed")
#+END_SRC

[[file:images/messageBox1.png][file:images/messageBox1.png]]

*** Password Dialog
    :PROPERTIES:
    :ID:       5a5958a5-88a7-4e65-88a8-0c117f2607fa
    :END:

 - File: [[file:src/passwordGui.scala][file:src/passwordGui.scala]]

#+BEGIN_SRC scala :tangle src/passwordGui.scala
import javax.swing.{JFrame, JLabel, JButton, JPanel, JPasswordField}

def getPassword(passwd: javax.swing.JPasswordField) =
  new String(passwd.getPassword())

/// Register callback function
///
def onClick(button: JButton) (handler: => Unit) = {
  button.addActionListener(
    new java.awt.event.ActionListener(){
      def actionPerformed(evt: java.awt.event.ActionEvent) = {
        handler
      }
    }
  )
}


def onWindowExit(frame: javax.swing.JFrame) (handler: => Unit) = {
  frame.addWindowListener(
    new java.awt.event.WindowAdapter(){
      override def windowClosing(evt: java.awt.event.WindowEvent) = {
        handler
      }
  })
}

val frame = new JFrame("Scala password entry")
frame.setSize(400, 200)
frame.setLayout(new java.awt.GridLayout(2, 1))

// frame.setLayout()

val panel  = new JPanel(new java.awt.FlowLayout())
val label  = new JLabel("Password")
val passwd = new JPasswordField(10)
val btn    = new JButton("Login")
val status = new JLabel("Safe closed")
passwd.setEchoChar('*')


panel.add(label)
panel.add(passwd)
panel.add(btn)


frame.add(panel)
frame.add(status)

frame.setVisible(true)

//--------- Event Handling ----------

def checkPassword(
  passwd: String,
  input: String,
  okHanlder: () => Unit,
  errHandler: () => Unit ) = {

  if (input == passwd)
    okHanlder()
  else
    errHandler()
}

onClick(btn){ println("I was clicked")}

onClick(btn) {
  val pass = getPassword(passwd)
  if (pass == "thepassword")
    println("Safe opened")
  else
    println("Error: Wrong password")
}

onClick(btn){
  checkPassword(
    "thepassword"
   ,getPassword(passwd)
   ,() => status.setText("Safe opened. Ok")
   ,() => status.setText("Error: Wrong password")
  )}

onWindowExit(frame){ System.exit(0) }

#+END_SRC


[[file:images/passwordGui1.png][file:images/passwordGui1.png]]

[[file:images/passwordGui2.png][file:images/passwordGui2.png]]

*** List View Dialog

The function listView is useful for data vizualization of lists,
files, numbers and son on.

 - File: [[file:src/listViewGui.scala][file:src/listViewGui.scala]]

#+BEGIN_SRC scala :tanngle src/listViewGui.scala
/// Function to visualize data in List View Mode
///
def listView(elements: Array[String]){
  val frame  = new javax.swing.JFrame("List Data View")
  val model  = new javax.swing.DefaultListModel[String]()
  val list   = new javax.swing.JList(model)
  val scroll = new javax.swing.JScrollPane(list)
  frame.add(scroll)
  elements.foreach(model.addElement)
  frame.setSize(300, 400)
  frame.setVisible(true)
}


def listFiles(path: String) = {
  (new java.io.File(path))
    .listFiles()
    .map(_.toString)
}

#+END_SRC

Show the files of directory /etc/

#+BEGIN_SRC scala
listView(listFiles("/etc"))
#+END_SRC

[[file:images/listViewFiles.png][file:images/listViewFiles.png]]


Show java properties

#+BEGIN_SRC scala
import scala.collection.JavaConverters._
val properties = System.getProperties().asScala.toArray.map { case (k, v) => k + " = " + v }
listView(properties)
#+END_SRC

[[file:images/listViewJavaProperties.png][file:images/listViewJavaProperties.png]]

*** Text View Dialog

#+BEGIN_SRC scala
  def textView(file: String) = {
    val frame = new javax.swing.JFrame("Text View App")
    val textArea = new javax.swing.JTextArea()
    val scroll = new javax.swing.JScrollPane(textArea)
    textArea.setText("")
    frame.add(scroll)
    frame.setSize(300, 400)
    frame.setVisible(true)
    val text = scala.io.Source.fromFile(file).mkString
    textArea.setText(text)
  }

  scala> textView("/etc/protocols")
#+END_SRC

[[file:images/textView1.png][file:images/textView1.png]]

*** Clock Display
    :PROPERTIES:
    :ID:       76e4cb5a-86e7-481e-972f-b29e41288d7b
    :END:

 - File: [[file:src/clockDisplayGui.scala][file:src/clockDisplayGui.scala]]

#+BEGIN_SRC scala :tangle src/clockDisplayGui.scala 
def runTimer(interval: Int, taskFn: () => Unit) = {
  val task = new java.util.TimerTask() {
    def run() {
      taskFn()
    }
  }

  val timer = new java.util.Timer()

  // Run the task every 1 second interval (or 1000 milli seconds)
  timer.schedule(task, 1, interval)
  timer
}

def currentTime() = {
  java.time.LocalDateTime.now.toString
}


val frame = new javax.swing.JFrame("Java Clock App")
val label = new javax.swing.JLabel("")
frame.add(label)
frame.setSize(375, 76)
frame.setVisible(true)


runTimer(1000, () => label.setText(currentTime()))

#+END_SRC


[[file:images/clockDisplayGui.png][file:images/clockDisplayGui.png]]

** Http Get Request

Java Code - https://www.mkyong.com/java/how-to-send-http-request-getpost-in-java/

#+BEGIN_SRC scala
  def httpGetRead(url: String) = {
    val obj = new java.net.URL(url)
    val conn = obj.openConnection().asInstanceOf[java.net.HttpURLConnection]
    conn.setRequestMethod("GET")
    conn.setRequestProperty("User-Agent", "Scala browser")
    val respCode = conn.getResponseCode()

    val bf = new java.io.BufferedReader(
      new java.io.InputStreamReader(conn.getInputStream()))

    val out = Stream.continually(bf.readLine())
      .takeWhile(_!=null)
      .mkString("\n")
    out
  }

  scala> httpGetRead("http://www.httpbin.org/get")
  res24: String =
  {
    "args": {},
    "headers": {
      "Accept": "text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2",
      "Connection": "close",
      "Host": "www.httpbin.org",
      "User-Agent": "Scala browser"
    },
    "origin": "186.212.135.2",
    "url": "http://www.httpbin.org/get"
  }

#+END_SRC
* Bookmarks and Resources 
** Scala API Documentation 

*Scala API*

 - Scala API - Standard Library. [[http://www.scala-lang.org/api/current/][Scala Standard Library 2.12.2]]


 - Collections - http://www.scala-lang.org/api/current/scala/collection/index.html


 - Math - http://www.scala-lang.org/api/current/scala/math/index.html


*Java API*

 - [[https://docs.oracle.com/javase/8/docs/api/][Overview (Java Platform SE 8 )]]

** Learning Resources 

 - [[https://www.scala-lang.org/][The Scala Programming Language]] - https://www.scala-lang.org/


 - [[https://twitter.github.io/scala_school/][Scala School]] - Twitter 


 - [[http://exercism.io/languages/scala/about][Scala - exercism.io]]


 - [[http://alvinalexander.com/scala][scala | alvinalexander.com]]


 - [[https://learnxinyminutes.com/docs/scala/][Learn Scala in Y Minutes]]


 - http://www.tutorialspoint.com/scala/

** Community 

 - [[https://users.scala-lang.org/][Scala Users]] - Forum 

 - https://stackoverflow.com/questions/tagged/scala

 - https://www.reddit.com/r/scala/


** Reports 

 - *Refactoring a Complex GUI Application: A Case Study with the
   Auckland Layout Editor* - <https://www.cs.auckland.ac.nz/~lutteroth/publications/theses/ALE-IreneZhang-2014.pdf>

 - 
